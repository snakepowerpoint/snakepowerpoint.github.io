<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  
  
  <meta name="description" content="Data Science">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    Rahul&#39;s Blog</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Rahul's Blog" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Rahul&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="Rahul&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-stock-position" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/09/12/stock-position/">看準位置，只賺不賠：掌握投資11大關鍵理論，買股不受傷</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/09/12/stock-position/" class="article-date">
  <time datetime="2021-09-12T06:57:27.000Z" itemprop="datePublished">2021-09-12</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E6%9B%B8%E6%91%98/">書摘</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <img src="/2021/09/12/stock-position/stock-position.jpg" class="">


<p>&nbsp;</p>
<h3 id="書目資訊"><a href="#書目資訊" class="headerlink" title="書目資訊"></a>書目資訊</h3><p>書名：看準位置，只賺不賠：掌握投資11大關鍵理論，買股不受傷<br>作者：郭泰<br>出版社：遠流<br>出版日期：2018/05/30</p>
<p>&nbsp;</p>
<h3 id="作者介紹"><a href="#作者介紹" class="headerlink" title="作者介紹"></a>作者介紹</h3><p><strong>郭泰</strong>，政大新聞系畢業。曾任中國時報記者、世新大學講師、哈佛企管顧問公司副總經理等職。年逾70仍筆耕不輟，苦心鑽研股票30年，悟出其中漲跌道理，並提出「位置理論」，成為股市分析之重要技術理論。</p>
<p>著作達35本，深入淺出的筆法為其一貫的寫作風格。曾榮獲「金鼎獎」與「金書獎」等殊榮。作品共有四大系列：企業人物系列、理財投資系列、個人競爭系列、勵志系列。其作品深又廣，不但暢銷，而且長銷。其中多部著作更是跨世代必讀經典。</p>
<p>&nbsp;</p>
<h3 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h3><p>導讀　讀通11大理論，幫你在股市趨吉避凶／陳忠慶｜前群益投信總經理、中國多家基金公司顧問</p>
<p>推薦文一　學習投資大師的智慧，買股不再受傷／99啪｜（財經作家）</p>
<p>推薦文二　讀郭泰這本書，買股不會受傷！／杜金龍｜資深證卷分析師</p>
<p>推薦文三　股市達人的投資基本功／林宏文｜《今周刊》顧問、財經節目主持人</p>
<p>自序　「等」的哲學</p>
<p>前言　跟著位置理論走，買股不受傷</p>
<p>第一章　價值理論</p>
<ul>
<li>價值理論的真諦就是在崩盤時買進物超所值的高殖利率績優股。採行價值理論買股，切記算算每年配息之後複利的驚人效益。</li>
</ul>
<p>第二章　循環理論</p>
<ul>
<li>股價永遠在上漲與下跌之間循環不已，漲久了就會跌，跌久了就會漲。聰明的投資人就懂得在循環中找到恰當的買賣點。</li>
</ul>
<p>第三章　位置理論</p>
<ul>
<li>進入股市之前，你一定要先知道大盤目前所處的位置：底部？中部？頭部？底部時買進，中部時等待，頭部時賣出，操作股票就是這麼簡單。</li>
</ul>
<p>第四章　時間理論</p>
<ul>
<li>股價的修正除了空間波，就是時間波。時間理論即是探討時間波修正的學問，它能協助投資人準確逮到頭部與底部。</li>
</ul>
<p>第五章　籌碼理論</p>
<ul>
<li>籌碼就是成交量。成交量是用銀彈堆砌起來的，所以最真實，不會騙人。它能有效地協助投資人找到頭部與底部。</li>
</ul>
<p>第六章　棄取理論</p>
<ul>
<li>在股市裡大家都知道要反市場操作，亦即人棄我取、人取我與，這個道理很簡單，但知易行難，大多數人都做不到。</li>
</ul>
<p>第七章　順勢理論</p>
<ul>
<li>股價走多頭行情時做多，走空頭行情時做空，順勢理論就這麼簡單。難的是，你必須有能力去研判目前是走多頭還是走空頭。</li>
</ul>
<p>第八章　停損理論</p>
<ul>
<li>股票是高風險的投資，萬一你買錯了方向，只有設下停損並嚴格執行，才能平安地把自己帶出場。</li>
</ul>
<p>第九章　抱股理論</p>
<ul>
<li>抓底不難，抱緊最難。投資人在底部買進的股票，一定要緊抱不放，直到大波段走完再出脫，這樣才能賺到倍數的利潤。</li>
</ul>
<p>第十章　主力理論</p>
<ul>
<li>股票若沒主力的拉抬不會飆漲，不論主力是外資、投信，還是公司派、業內，你都必須洞悉他們的心態與手法，才不會被他們玩弄於股掌之間。</li>
</ul>
<p>第十一章　選股理論</p>
<ul>
<li>股票是投資工具，也是投機工具。投資者愛績優股，投機者愛投機股，投資與投機並存於股市，分工互補，缺一不可。</li>
</ul>
<p>附錄</p>
<p>&nbsp;</p>
<h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>本書是郭泰投入股市30餘年的心得彙整，作者總結了自己數十年來的操盤經驗，以及20本經典投資書籍的內容，歸納出11個投資的經典理論，包含價值理論、循環理論、位置理論、時間理論、籌碼理論、棄取理論、順勢理論、停損理論、抱股理論、主力理論、選股理論。</p>
<p>這些理論中，最重要的就是位置理論，其他理論基本上都是基於位置理論發展而成。想要在股市中賺錢，就必須要低買高賣，而位置理論就是在告訴投資人，股市有分頭部和底部，看清楚底部的位置後，大膽買進，接著長抱股票，等到頭部來臨時，再一舉獲利了結，這就是股票投資的聖盃。</p>
<p>底下我總結各個理論的內容：</p>
<blockquote>
<p><strong>價值理論</strong></p>
</blockquote>
<p>價值理論又稱為<strong>價值投資（value investing）</strong>，是由美國著名的基金經理人<strong>班傑明‧葛拉漢（Benjamin Graham）</strong>所提出，這套理論的核心思想是：<strong>任何股票不論股價怎麼漲跌，從長期來看，股價必定會反映其真實的價值</strong>。因此，當一間長期穩定獲利的公司，其股價跌到淨值以下時，且又沒有其他負面因子影響時，那麼目前的股價就是低估了，投資人應該要大膽買進。</p>
<p>這種操作有幾種好處，第一，當投資人用低於淨值的股價買入一間公司，相當於佔到了便宜。第二，這種投資符合安全邊際，也就是股票的投資報酬率高於績優債券的投資報酬率，因此獲利的機率高。第三，價值投資非常適合散戶，因為散戶擁有的資訊比法人少很多，所以只要嚴守「安全邊際」的原則去購買股票，就比較不容易吃虧。</p>
<p>著名的股神巴菲特（Buffett），其實就是價值投資之父班傑明‧葛拉漢的嫡傳弟子。巴菲特在他所擁有的波克夏‧海瑟威公司中，長年透過這種價值投資法，獲得了巨大的收益。而巴菲特的過人之處，就是擅長找出目前受到市場低估的股票，然後傾全力投入資金，並長期持有。</p>
<blockquote>
<p><strong>循環理論</strong></p>
</blockquote>
<p>股價和景氣息息相關，當景氣繁榮時，會刺激股價上漲，當景氣衰退時，可能導致股價下跌。因此，股價自然也和景氣一樣具有<strong>循環</strong>的現象，這就是循環理論。</p>
<p>最早提出股價循環的人是美國紐約《華爾街日報》的創始人查理士‧道（Charles H. Dow），後來美國的股市天才艾略特（Elliott）根據這個現象，發展出八波段循環理論。該理論指出，股價在一個完整的走勢中，會呈現八個波段走法，而當八個波段走完後，會開始另一個八波段的走勢，周而復始，不斷循環。</p>
<img src="/2021/09/12/stock-position/eight-wave.JPG" class="">

<p><strong>八個波段中，包含三個主要的上升階段（第一、三、五波），以及二個主要的下跌階段（第六、八波）。</strong>第一至第五波段是多頭行情，其中，第一波段又稱為初升段，第三波段為主升段，第五波段為末升段，而二、四波段的下跌是回檔整理。另一方面，第六至第八波段是空頭行情，其中，第六波段為初跌段，又稱為A波，第七波段是反彈逃命波，俗稱B波，而第八波段為主跌段，又稱為C波。</p>
<p>波浪理論並不一定完全能解釋歷史股價，有時多頭行情只有二波，也就是到第三波主升段後，緊接著就是空頭行情。此外，根據艾略特的研究，八波段中還會隱含一些小波段，總共可分為34個小波，甚至144個小小波。不過，作者認為這些小波、小小波的參考意義不大，主要還是以八波段為主。</p>
<p>無論如何，歷史告訴我們股價會周而復始地循環，這背後的邏輯其實就是人類追求財富的過程，也就是買進股票、追價、一直到獲利了結的過程，而這就是循環理論所要點出的核心概念。</p>
<blockquote>
<p><strong>位置理論</strong></p>
</blockquote>
<p>基於循環理論，我們可以從八波段的循環走勢中，判斷大盤加權指數與個股所處的位置，將股價分為底部、頭部及中部。想要在股票市場中賺錢，就必須低買高賣，所以我們要<strong>在底部大膽地分批買進</strong>，然後<strong>在頭部果斷地分批賣出</strong>。至於要如何判斷目前股價是處於什麼位置，作者指出，台股每一次循環來到底部區時，都會出現七個訊號：</p>
<ul>
<li><p>月k線走完艾略特的八個波段</p>
</li>
<li><p>月成交量大幅萎縮</p>
</li>
<li><p>融資餘額的跌幅大於大盤的跌幅</p>
</li>
<li><p>月k線走完八波段後，股價盤整不再破底</p>
</li>
<li><p>國安基金進場護盤時</p>
</li>
<li><p>政府一連串干預動作</p>
</li>
<li><p>月k線走完八波段後出現月紅k線</p>
</li>
</ul>
<p>當然，要精準抓出底部仍然十分困難，我們可以退而求其次，在次底部區買進股票，也就是在八波段中的第二波段回檔時，買進股票，然後靜待頭部區的到來，再獲利了結。作者指出，台股每一次來到頭部區時，都會出現五個訊號：</p>
<ul>
<li><p>月k線走完多頭行情的五個波段</p>
</li>
<li><p>月KD在80附近形成死亡交叉</p>
</li>
<li><p>與費波南希數列的時間波吻合</p>
</li>
<li><p>股價跌破上升趨勢線</p>
</li>
<li><p>股價跌破移動平均線的年線</p>
</li>
</ul>
<p>當越多的指標同時出現時，就代表頭部即將成立，空頭行情即將來臨。除了這五個訊號外，還有日k線形成做頭型態、M1b與M2形成死亡交叉、成交量暴增、最大量月k線的低點倍跌破、5月RSI呈現背離等現象。</p>
<blockquote>
<p><strong>時間理論</strong></p>
</blockquote>
<p>波浪理論是從<strong>空間的角度</strong>來解釋股票的循環現象，也就是用八個波段來解釋股票。除了空間概念，我們也可以用<strong>時間的角度</strong>來解釋股票的循環現象，例如走完一次八波段循環需要多少個月，或是每個上升波段會維持多少月，這就是時間理論。</p>
<p>作者指出，無論從空間波亦或時間波來看，股價循環的過程都會出現<strong>費波南希數列</strong>中的數字。例如在空間波中，股價循環包含1個多頭行情以及1個空頭行情，而這二個1分別就是費波南希數列的前二個數字。再者，八波段是由5個多頭行情波段及3個空頭行情波段所組成，而5和3也是費波南希數列中的數字。</p>
<p>從時間波來看，台股的第一次循環從1982年8月的421點，一直到1990年2月的12682點，剛好漲了89個月，而89正是費波南希數列中的數字。同理，台股第二、三、四次循環中的波段持續時間，也分別能找到費波南希數列中的數字。這意味著，我們能用費波南希數列中的數字來預估底部和頭部的位置，這就是時間理論。</p>
<p>作者總結，用費波南希數列去預測台股時，<strong>多頭行情（抓頭）要留意34、55、89等月份，而空頭行情（摸底）則留意8、13、21等月份。</strong></p>
<blockquote>
<p><strong>籌碼理論</strong></p>
</blockquote>
<p><strong>成交量</strong>是多方或空方用銀彈堆砌起來的，不可能是假的，所以它<strong>是唯一能夠代表股市真實情況的指標</strong>。所謂新手看價，老手看量，股價通常是主力誘多或誘空的工具，參考價值較低，必須要搭配成交量來判斷走勢。一般來說，成交量是股票的先行指標，多頭行情若要發動，必須要<strong>量價配合</strong>，也就是價漲量增。反之，如果出現<strong>量價背離</strong>的情況，則股價容易轉弱，形成空頭行情。因此，我們可以透過成交量來判斷大盤或個股的走勢。</p>
<p>作者指出，底部區出現時，成交量會有以下幾種變化：</p>
<ul>
<li><p>月成交量大幅萎縮</p>
</li>
<li><p>融資餘額的跌幅大於大盤的跌幅</p>
</li>
<li><p>從週成交量看出已經打底成功</p>
<p>一般而言，當股價從高檔下殺時，每週成交量的總和，就是上檔套牢區的賣壓；而當股價來到底部橫向盤整時，就是在消化套牢賣壓。當盤整時期的成交量總和超過套牢賣壓時，股價才有機會反轉向上。</p>
</li>
<li><p>個股週k線明顯出量</p>
<p>若股票在底部盤整時，發現週k明顯出量的話（成交量約為平時的1.5-2倍），通常是主力在底部吃貨的跡象。</p>
</li>
<li><p>籌碼從猶豫者手中轉到固執者手中</p>
<p>當股票多數由固執者持有的話，就比較不容易對利空消息有反應（利空不跌），股價會逐漸止跌。</p>
</li>
<li><p>W底打底的成交量特徵</p>
<p>量價同步，即價跌量縮，價漲量增，買盤力道逐漸增強。</p>
</li>
</ul>
<p>另一方面，頭部區出現時，成交量會有以下幾種變化：</p>
<ul>
<li><p>月成交量暴增</p>
</li>
<li><p>最大量月k線的低點被跌破</p>
</li>
<li><p>月成交量出現量價背離</p>
<p>例如股價接近或過前高，但是成交量卻萎縮，出現量價背離</p>
</li>
<li><p>籌碼從固執者手中轉到猶豫者手中</p>
</li>
<li><p>M頭做頭的成交量特徵</p>
<p>第二高峰（右邊）的成交量低於第一高峰（左邊），顯示多頭買盤力道的縮減。</p>
</li>
</ul>
<blockquote>
<p><strong>棄取理論</strong></p>
</blockquote>
<p>當市場大多數人看壞行情時，就是空頭行情即將結束的時候。反之，當市場大多數人看好行情時，表示多頭行情即將走到盡頭。正如巴菲特的名言：<strong>別人貪婪時我恐懼，別人恐懼時我貪婪</strong>。</p>
<p>此外，<strong>群眾是盲目的</strong>，身處在群眾之中，最容易迷失自己。原因有三：</p>
<ul>
<li><p>群體相互激盪、彼此影響 <strong>&rarr;</strong> 因此容易分不清主觀與客觀</p>
</li>
<li><p>群眾是無知的，不受理性支配，由情緒指揮 </p>
</li>
<li><p>個體追隨群體，個人根據群眾</p>
<p>一個成熟理性的投資人，在市場上受到群眾影響，也會出現非理性的行為。</p>
</li>
</ul>
<blockquote>
<p><strong>順勢理論</strong></p>
</blockquote>
<p>新手看價，老手看量，高手看勢，順勢操作通常都會是贏家。順勢理論由股市名人威爾斯‧威爾德發明，並稱之為「<strong>亞當理論</strong>」。順勢的精髓在於：研判股市走多頭的最佳方式，就是看到它已經在上漲。值得注意的是，亞當理論主張，當投資人進場後，開始出現虧損時，<strong>千萬不要「加碼攤平」</strong>，因為賠錢就代表自己看錯趨勢，應該盡快停損。</p>
<p>當大盤趨勢走多時，必須要追逐最強勢的類股，以台股來說，傳產股通常是漲勢最為強勁的類股，前三名為<strong>汽車類、玻璃陶瓷類、建材營造類</strong>。另外，追逐時下最夯的產業，也是順勢操作的手法之一。</p>
<blockquote>
<p><strong>停損理論</strong></p>
</blockquote>
<p>相較於定存，股票本身是風險較高的投資，即便是股市高手也會看錯行情。因此在<strong>進場前，就必須嚴設停損點</strong>，才能在投資失利時，將自己平安帶出場。美國股市作家吉姆‧史洛門所（Jim Sloman）認為停損有三個要點：</p>
<ul>
<li><p>在進場前，就必須先設下自己可以接受的停損點</p>
</li>
<li><p><strong>進場前的停損點絕對不能更動</strong>，這樣才能保持客觀</p>
</li>
<li><p>千萬不要因小失大，看錯行情就要立刻停損</p>
</li>
</ul>
<p>作者提供三種停損的方法：</p>
<ul>
<li><p>當股市跌破重要支撐點時</p>
</li>
<li><p>當買進的理由改變時</p>
</li>
<li><p>當股價跌破一定的百分比時</p>
<p>作者建議當虧損超過10%時，是不錯的停損點</p>
</li>
</ul>
<p>最後，低檔買進股票也要設停損點，而<strong>放空更需要設停損點</strong>，因為做多頂多虧損100%（股票跌到0元），做空的虧損理論上可以無限大（股票一直上漲）。</p>
<blockquote>
<p><strong>抱股理論</strong></p>
</blockquote>
<p>美國投機大師傑西‧李佛摩（Jesse Livermore）認為：在多頭行情裡，只需要做二件事，分別是<strong>底部區買進</strong>與<strong>緊抱持股</strong>。然後，忘記你擁有的股票，一直到多頭行情即將結束為止。</p>
<p>其實，要在股市抓到底部不難，難的是長抱持股。大多數人總是在股市中小賺大賠，就是因為貪圖眼前的蠅頭小利，導致在買進股票後，很快就停利，然後又在股票上漲時追高進場，最後慘遭套牢，導致大賠。</p>
<p>不過，抱股理論和買進股票的位置有很大的關係，如果是在高檔買進股票，那麼緊抱持股可能會賠得相當悽慘。因此，抱股理論要<strong>搭配位置理論</strong>使用，先用位置理論判斷出底部後，勇敢買進股票，然後緊抱持股，最後再透過位置理論判斷頭部，果斷賣出。</p>
<p>台灣《理財聖經》的作者黃培源也曾提出類似的概念，他認為，投資股票只有九個字：<strong>隨便買、隨時買、不要賣</strong>。主要原因是因為股市基本上是長期看漲的，所以只要身邊有錢，就可以去買股票，並且盡量不要賣出，因為高額的手續費和交易稅都會侵蝕利潤。</p>
<p>最後，引用美國投資大師吉姆‧羅傑斯（Jim Rogers）的話：「用便宜的價格買進物超所值的東西，並且長期持有，不理會市場上其他人的聲音。這是從事投資最重要的課題。」</p>
<blockquote>
<p><strong>主力理論</strong></p>
</blockquote>
<p>股票如果沒有主力拉抬，是不會飆漲的。想在股市賺錢，一定要洞悉主力的思考模式和操作手法。一般而言，主力在操作一檔股票時，有以下幾個步驟：</p>
<ul>
<li><p>挑選標的</p>
<p>主力是不會隨便選一檔標的進行炒作的，通常會經過深入的分析後，再採取行動。一般來說，主力挑出來的標的會具備四個要件：</p>
<ul>
<li><p>股本小</p>
<p>通常是10億以下，相對容易拉抬</p>
</li>
<li><p>股性投機</p>
<p>例如很少配息、但在多頭行情漲幅可觀者</p>
</li>
<li><p>炒作題材</p>
<p>高明的主力在挑選股票時，會同時兼顧其業績和產業特性，例如景氣循環股、有基本面題材等</p>
</li>
<li><p>公司派的首肯</p>
<p>有些主力在炒作前，會和公司的大股東或董監事談妥條件，以免被倒貨</p>
</li>
</ul>
</li>
<li><p>估算籌碼</p>
<p>主力在估算籌碼時，必須考慮三個要素：</p>
<ul>
<li><p>精確估算市場浮額</p>
<p>依照上市櫃公司的資本額以及每股10元，算出市場上發行的所有股數，再扣掉董監等大股東的持股，剩下的股票就是<strong>市場浮額</strong></p>
</li>
<li><p>避免和其他主力作對</p>
<p>主力在挑選標的時，會先調查標的本身的主力，免得替人抬轎，或是淪為出貨的對象</p>
</li>
<li><p>精確估算需要吸納的籌碼</p>
<p>主力手上的籌碼如果不夠，在拉抬股票時就無法得心應手，所以主力通常會先吸收籌碼，一般來說是<strong>市場浮額的三成</strong></p>
</li>
</ul>
</li>
<li><p>外圍搭配</p>
<p>主力炒作股票不會孤軍奮戰，通常會搭配基金經理人、外資、自營商、其他主力、投顧老師、媒體等</p>
</li>
<li><p>進貨</p>
<p>主力在挑選完標的、計算完籌碼後，就會開始吃貨。常見的吃貨方法有二種，一種是直接在市場上買進股票，另一種方法是和公司派的人合作，轉讓鉅額籌碼。前者通常會搭配媒體發布利空消息，或利用手中的籌碼壓低股價，以便在底部區收購股票，吃貨時間一般落在三個月到六個月之間。</p>
</li>
<li><p>拉抬</p>
<p>一般而言，主力都是熟悉<strong>技術分析的高手</strong>，他們會精算市場浮額，並依照波浪理論或技術分析將股價拉抬到相對應的位置，再配合媒體釋放利多消息，利用基本面改善、景氣循環、市場結構轉變等利多新聞拉抬股價。</p>
<p>不過，主力的操作習性可能因人而異，未必會全然按照技術分析或波浪理論操作。因此，作者建議投資人可以<strong>在第二波高點獲利了結</strong>，降低投資風險。</p>
</li>
<li><p>洗盤</p>
<p>主力在拉抬股價的過程中，通常會伴隨著洗盤，亦即回檔整理。原因有二，一是為了洗出底部區進場的投資人，二是吸引新的投資人進場，墊高投資人的成本，以利之後出貨。常見的洗盤方式有三種：</p>
<ul>
<li><p>高出低進法</p>
<p>這是最常見的洗盤法，主力會在高點製造強力賣壓，壓低股價，然後在低點接回股票。除了能清洗籌碼以外，也能賺到價差。</p>
</li>
<li><p>定點洗盤法</p>
<p>在某一個區間內來回盤整，以洗出沒有耐心的投資人。</p>
</li>
<li><p>跌停洗盤法</p>
<p>這是最激進的洗盤法，在沒有大利空的情況下，突然讓股價跌停，誘使投資人交出手中的籌碼，筆者在去年就曾經遇到過（淚）。幸好當時並沒有被甩掉，並且在接下來三個多月的盤整也沒有交出手中籌碼，最後才迎來今年的波段獲利。</p>
<img src="/2021/09/12/stock-position/2376-week-202109.JPG" class=""></li>
</ul>
</li>
<li><p>出貨 </p>
<p>正所謂「萬般拉抬皆為出」，主力苦心布局一檔股票，就是為了出貨。</p>
<ul>
<li><p>拉高出貨法</p>
<p>主力在拉高出貨的前幾個交易日，會在尾盤強拉股票，吸引投資人進場，最後透過震盪回檔，出貨給投資人。</p>
</li>
<li><p>壓低出貨法</p>
<p>當股價達到主力預設的高點後，就一路壓低賣出。</p>
</li>
<li><p>震盪出貨法</p>
<p>這是主力最高明的出貨方法，在股價高檔震盪期間就出貨完畢，讓投資人誤以為是在洗盤而進場，最後慘遭套牢。</p>
</li>
</ul>
</li>
</ul>
<p>除了操作股票的步驟外，主力還有一些操作股票的心態和習性：</p>
<ul>
<li><p>若非當時的當紅產業，業績不夠好，公司沒有大利多，主力通常不敢介入</p>
</li>
<li><p><strong>主力炒作股票不會二、三個漲停板就結束</strong>，其漲幅通常以倍數來計算</p>
<p>筆者以今年大爆發的友達為例，2020/12/04出現過前高的漲停板，即暗示著未來的波段行情。不過，在隨後的二個月，友達呈現盤整期間，並且成交量相較過去幾周有逐漸放大的趨勢，顯示市場熱度正在增加，且主力洗盤中，這也印證了本書所述的主力操作手法。</p>
<img src="/2021/09/12/stock-position/2409-week-202109.JPG" class=""></li>
<li><p>在波浪理論第八波段尾端，當周k出現連續二周的大量，很可能是主力在吃貨</p>
</li>
<li><p>有主力介入的股票，通常會以長紅k或跳空的方式越過前高或頸線等大型壓力區</p>
</li>
<li><p><strong>只有主力介入的股票才會飆漲</strong></p>
</li>
<li><p>主力出貨的量大約是其拉抬過程中最大的二倍</p>
</li>
<li><p>在炒作的過程中，主力最在乎的是收盤價，因此可以從股票的收盤價看出是否有主力介入</p>
</li>
<li><p><strong>主力並不是每一次的炒作都會成功</strong>，偶爾也會遇到對作或是突發的利空而失敗出場，此時k線就會出現跌破大支撐的現象</p>
</li>
</ul>
<blockquote>
<p><strong>選股理論</strong></p>
</blockquote>
<p>股市中永遠存在二種股票，一種為績優股，另一種為投機股。績優股通常具備幾種要素，例如是產業數一數二的正派龍頭股、上市多年來獲利率超過10%、業績持續不斷成長、獲利能力比同業佳、經營者正派經營且具公信力。以台灣上市公司而言，績優股有台塑、台化、永信製藥、中碳、台積電、統一超商、中華電、台灣大等。</p>
<p>購買績優股的投資人，應該對績優股有正確的認識：</p>
<ul>
<li><p>買績優股著眼於配股配息</p>
<p>如果想追求價差，那應該買投機股，不是績優股。</p>
</li>
<li><p>績優股沒飆漲的條件</p>
<p>這是因為績優股的股本通常很龐大，不容易拉抬，且會去買績優股的投資人大多都是穩健型的投資人以及法人機構，因此不會去哄抬或炒作股價。</p>
</li>
<li><p>績優股須長期投資始見效益</p>
<p>績優股不會飆漲，所以不太能透過價差賺到錢。但是績優股年年配息，如果長期投資的話（如十年、二十年），就會見到<strong>複利的效益</strong>。</p>
</li>
</ul>
<p>相反的，買投機股應該有以下幾點認識：</p>
<ul>
<li><p>買投機股著眼於階段性價差</p>
</li>
<li><p>投機搶短，眼明手快</p>
<p>當股價漲到目標價後，立即獲利了結；當股價跌過停損點後，立刻殺出。</p>
</li>
<li><p>必須具備一定的功力</p>
<p>買賣投機股必須要對技術面瞭若指掌，也要對籌碼、主力有相當程度的理解，才能在股市中獲取報酬。</p>
</li>
</ul>
<p>&nbsp;</p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>本書的核心思想是「<strong>低買高賣</strong>」，也就是書中所述的位置理論。為了達到這個目的，需要有其他對應的資訊來幫助判斷股票什麼位置是「低」，什麼位置是「高」，以及什麼時候要「買」，什麼時候要「賣」，故而衍伸出其他理論。</p>
<p>例如價值理論可以幫助投資人判斷股價是否合理，而循環、時間理論則幫助投資人判斷股價的趨勢以及持續的時間。籌碼和主力理論幫助投資人判斷市場大戶的動向，再搭配順勢、棄取理論進場操作。若操作不慎，則透過停損理論降低虧損；看對方向的話，則根據抱股理論長抱持股。當然，投資人必須清楚知道自己持有的股票是績優股還是投機股，以便選擇相對應的操作。</p>
<p>整體而言，這本書對股市作了一個相當不錯的全面性總結，屬於<strong>大面相觀念書</strong>。書中所述的理論都是符合邏輯、非常實用的觀念，而不是牽強地去解釋歷史股價，建議重複閱讀，並將這些觀念內化到自己的思想中。本書所涵蓋的範圍包含股市的各個面向，例如<strong>基本面、技術面、籌碼面、消息面</strong>等，但並沒有針對各個面向仔細地介紹，而是將這些面向統整成一個單一的理論，然後用理論去解釋股市在多頭或空頭時，各個面向會如何反應。此外，本書的用字遣詞大多屬於股市的術語，例如k線、籌碼、底部、頭部等，因此適合已經在股市打滾一陣子、股齡約一到二年的投資人，<strong>較不適合新手閱讀</strong>。</p>
<p>對我來說，收穫比較大的觀念是：<strong>機會是「等」來的</strong>。要在股市中賺錢，不外乎低買高賣，或者低買後長抱。但是，低價的股票並不是每天都有，而是需要長時間的等待，這抑制了我追漲的衝動，降低被套牢的風險。另外，<strong>主力理論</strong>是我先前比較少接觸到的領域，讀完後猶如醍醐灌頂，讓我明白為什麼股票會有拉抬、回檔、洗盤、出貨等階段。回頭對照以前操作過的股票後，真是令我會心一笑，原來主力在股市根本毫不掩藏（笑）。最後，作者有提到，這些理論是他在讀完數十本股市經典的書籍後所整理出來的，我認為這份<strong>書單</strong>對於投資人有相當大的參考價值，如果讀完本書覺得意猶未盡的話，可以再深入去看這些經典書籍。</p>
<p>總的來說，這是一本值得閱讀的財經書籍，熟記這些理論，並做好風險控管，相信大家都能在股海中獲利！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://snakepowerpoint.github.io/2021/09/12/stock-position/" data-id="cktzmt5gi000nhxqagynhdyiq" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%95%E8%B3%87/" rel="tag">投資</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%82%A1%E7%A5%A8/" rel="tag">股票</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-min-cost-ticket" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/09/02/min-cost-ticket/">LeetCode 983. Minimum Cost For Tickets</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/09/02/min-cost-ticket/" class="article-date">
  <time datetime="2021-09-02T16:15:25.000Z" itemprop="datePublished">2021-09-03</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/">程式</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/">LeetCode</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/Array/">Array</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.</p>
<p>Train tickets are sold in three different ways:</p>
<ul>
<li>a 1-day pass is sold for costs[0] dollars,</li>
<li>a 7-day pass is sold for costs[1] dollars, and</li>
<li>a 30-day pass is sold for costs[2] dollars.</li>
</ul>
<p>The passes allow that many days of consecutive travel.</p>
<ul>
<li>For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.</li>
</ul>
<p>Return the minimum number of dollars you need to travel every day in the given list of days.</p>
<p>這是我第一次碰到 dynamic programming (DP) 問題，其實最早碰到的應該是費布納西數列，不過那個問題相對簡單。</p>
<p>本題考 DP 觀念，想法上是第 i 天的花費，是截至第 i-1 天的花費再加上當天的花費。因此，如果第 i 天不用旅遊的話，那該天的花費就是累積到第 i-1 天的花費。反之，如果第 i 天要旅遊的話，那麼有三種情況，分別是第 i-1 天加上 1-day pass、第 i-7 天加上 7-day pass、第 i-30 天加上 30-day pass。透過這種推法，就能導出每個 travel day 的最低花費。要注意的是，起始值 DP(0) 要給一個合理的數字，才能透過 DP 演算法一直往下推 DP(1), DP(2), …, DP(t)。本題把 DP(0) 設為 0 （花費為 0）是個合理的設定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span>(<span class="params">self, days: <span class="type">List</span>[<span class="built_in">int</span>], costs: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * <span class="number">366</span></span><br><span class="line">        <span class="keyword">for</span> day <span class="keyword">in</span> days:</span><br><span class="line">            dp[day] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># set initial point</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">366</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i] == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>):</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                case1 = dp[<span class="built_in">max</span>(i-<span class="number">1</span>, <span class="number">0</span>)] + costs[<span class="number">0</span>]</span><br><span class="line">                case2 = dp[<span class="built_in">max</span>(i-<span class="number">7</span>, <span class="number">0</span>)] + costs[<span class="number">1</span>]</span><br><span class="line">                case3 = dp[<span class="built_in">max</span>(i-<span class="number">30</span>, <span class="number">0</span>)] + costs[<span class="number">2</span>]</span><br><span class="line">                </span><br><span class="line">                dp[i] = <span class="built_in">min</span>(case1, case2, case3)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[days[-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://snakepowerpoint.github.io/2021/09/02/min-cost-ticket/" data-id="cktzmt5gc000chxqa61lf4djg" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/medium/" rel="tag">medium</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-three-sum" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/09/01/three-sum/">LeetCode 15. 3Sum</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/09/01/three-sum/" class="article-date">
  <time datetime="2021-09-01T15:03:49.000Z" itemprop="datePublished">2021-09-01</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/">程式</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/">LeetCode</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/Array/">Array</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j, i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<p>題目是給定一串數列，找出所有3個為一組且不重複的 triplets，使得這3個數字的總合為0。</p>
<p>這題的解法比較複雜，首先，最簡單的做法是暴力解，需要考慮 <code>nums</code> 中所有可能的 triplets，時間複雜度會是 $O(N^3)$。</p>
<p>第二種解法需要用到二個指針的操作，並且假設 <code>nums</code> 是已經排序過的。針對一個已經排序的 <code>nums</code>，例如題目給的例子是 <code>[-1,0,1,2,-1,-4]</code>，排序後為 <code>[-4,-1,-1,0,1,2]</code>，目標是要在這裡面找到 a, b, c 三個數字，使得 a + b + c = 0。因為 <code>nums</code> 已經排序過，我們可以假設 a &lt; b &lt; c，先把 a 當成第一個數字，也就是 -4，接下來要找的 b 和 c 必須符合 b + c = -4。找法是先放二個指針，一個在頭，一個在尾，例如 b = -1, c = 2，然後把它們相加，如果和比 a 小，表示 b 要往右邊移動去找更大的數字（因為 <code>nums</code> 已經排序）；反之，如果和比 a 大，那麼 c 就要往左移動，去找更小的數字。</p>
<p>另一種解法和前述雙指針的解法類似，一樣先將 <code>nums</code> 排序，接著從第一個數開始，依序當作 triplets 中的一個數值 v，然後從剩下的數去找 triplets 中的另外二個數字。假設另外二個數值其中一個是 x，則另一個一定是 -v-x，三者相加 v + x + (-v-x) = 0。重複前面的步驟，遍歷 <code>nums</code> 中所有的數字，就能得到所有的 triplets。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums[:n-<span class="number">2</span>]):</span><br><span class="line">            <span class="comment"># if nums[i] = nums[i-1], no need to check</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums[(i+<span class="number">1</span>):]:</span><br><span class="line">                <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[-v-x] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.add((v, -v-x, x))</span><br><span class="line">        <span class="keyword">return</span> res        </span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://snakepowerpoint.github.io/2021/09/01/three-sum/" data-id="cktzmt5gj000ohxqa81maf6n0" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/medium/" rel="tag">medium</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-longest-palindromic-subs" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/09/01/longest-palindromic-subs/">LeetCode 5. Longest Palindromic Substring</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/09/01/longest-palindromic-subs/" class="article-date">
  <time datetime="2021-09-01T13:45:58.000Z" itemprop="datePublished">2021-09-01</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/">程式</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/">LeetCode</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/Array/">Array</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a string s, return the longest palindromic substring in s.</p>
<p>本題主要考 string 操作。想法上先建一個 helper function 來找回文的 substring，然後從 string 頭開始，依序帶入 substring 去找回文，並在過程中儲存目前長度最長的 substring，最後便可找到答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            subs = self.find_palindrome(s[i:])</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(subs) &gt; max_len:</span><br><span class="line">                max_len = <span class="built_in">len</span>(subs)</span><br><span class="line">                ans = subs</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_palindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>):</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        end = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            end = s.find(s[<span class="number">0</span>], end+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> end == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            subs = s[:(end+<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">if</span> subs == subs[::-<span class="number">1</span>]:</span><br><span class="line">                res = subs</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://snakepowerpoint.github.io/2021/09/01/longest-palindromic-subs/" data-id="cktzmt5g90008hxqadfdacbqg" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/medium/" rel="tag">medium</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-longest-substring-no-repeat" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/08/31/longest-substring-no-repeat/">LeetCode 3. Longest Substring Without Repeating Characters</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/08/31/longest-substring-no-repeat/" class="article-date">
  <time datetime="2021-08-31T16:31:01.000Z" itemprop="datePublished">2021-09-01</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/">程式</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/">LeetCode</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/Array/">Array</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>Given a string s, find the length of the longest substring without repeating characters.</p>
<p>本題主要測驗 string 的操作，如 slicing 及找尋 substring。解法是依序建立 substring，當遇到有重複的字元時，拿掉該字元以前的所有字元，從該重複字元的下一個開始，並且新增當前的字元。依此類推，當遇到比較長的 substring 時，更新 substring 的長度。全部跑完就能得到最長的 substring。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        subs = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> subs:</span><br><span class="line">                <span class="keyword">if</span> ans &lt; <span class="built_in">len</span>(subs):</span><br><span class="line">                    ans = <span class="built_in">len</span>(subs)</span><br><span class="line">                </span><br><span class="line">                pos = subs.find(x) + <span class="number">1</span></span><br><span class="line">                subs = subs[pos:] + x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                subs += x</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ans &lt; <span class="built_in">len</span>(subs):</span><br><span class="line">            ans = <span class="built_in">len</span>(subs)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://snakepowerpoint.github.io/2021/08/31/longest-substring-no-repeat/" data-id="cktzmt5ga0009hxqabauy71rz" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/medium/" rel="tag">medium</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-add-two-numbers" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/08/29/add-two-numbers/">LeetCode 2. Add Two Numbers</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/08/29/add-two-numbers/" class="article-date">
  <time datetime="2021-08-29T16:30:07.000Z" itemprop="datePublished">2021-08-30</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/">程式</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/">LeetCode</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/Array/">Array</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>這題主要測驗的是 <code>Linked list</code> 的操作，以及餘數的處理。首先新增一個空的 <code>List</code>，並新建一個餘數。接著，遍歷 <code>l1</code> 及 <code>l2</code>，當有述職的時候，就按照位置相加，並且更新餘數，直到 <code>l1</code> 及 <code>l2</code> 都沒有 <code>next</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        head = ans = ListNode()</span><br><span class="line">        remainder = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> remainder:</span><br><span class="line">            l1_val = l1.val <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            l2_val = l2.val <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            summation = l1_val + l2_val + remainder</span><br><span class="line">            remainder = summation // <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            ans.<span class="built_in">next</span> = ListNode(summation % <span class="number">10</span>)</span><br><span class="line">            ans = ans.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://snakepowerpoint.github.io/2021/08/29/add-two-numbers/" data-id="cktzmt5g40003hxqa2bck3bf4" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/medium/" rel="tag">medium</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-two-sum" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/08/29/two-sum/">LeetCode 1. Two Sum</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/08/29/two-sum/" class="article-date">
  <time datetime="2021-08-29T11:03:58.000Z" itemprop="datePublished">2021-08-29</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/">程式</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/">LeetCode</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/Array/">Array</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>You can return the answer in any order.</p>
<p>一開始的思路是暴力解法，遍歷 <code>nums</code> 中每個數字，然後找該數字是否和後面的數字相加得到 <code>target</code>，不過這個方法最差的情況應該會是 <code>n!</code>，所以換個方式。</p>
<p>另一個想法是從減法的角度來解，並解透過 hash table 來記錄 <code>nums</code> 中所有元素的 index。做法如下：先建立一個 hash_table，然後遍歷 <code>nums</code> 中所有元素，計算當下元素和 <code>target</code> 的差，然後看 hash_table 裡面有沒有這個差，有的話，等於是得到答案：因為當前這個數字與 hash_table 裡的元素的和就是 <code>target</code>，因此，只要返回當前元素的 index 以及 hash_table 中差值元素的 index 即可。</p>
<p>如果差不存在的話，則將目前的元素及其 index 存入 hash_table，繼續找下一個。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hash_table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            diff = target - num</span><br><span class="line">            <span class="keyword">if</span> diff <span class="keyword">in</span> hash_table.keys():</span><br><span class="line">                <span class="keyword">return</span> [hash_table[diff], i]</span><br><span class="line">            hash_table[num] = i</span><br><span class="line">            </span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://snakepowerpoint.github.io/2021/08/29/two-sum/" data-id="cktzmt5gm000shxqadn7b6jjx" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/easy/" rel="tag">easy</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-remove-element" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/08/29/remove-element/">LeetCode 27. Remove element</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/08/29/remove-element/" class="article-date">
  <time datetime="2021-08-29T08:17:37.000Z" itemprop="datePublished">2021-08-29</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/">程式</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/">LeetCode</a> / <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BC%8F/LeetCode/Array/">Array</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.</p>
<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.</p>
<p>Return k after placing the final result in the first k slots of nums.</p>
<p>Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>題目並不難，大意是給定一個含有整數的陣列 <code>nums</code> 及一個整數 <code>val</code>，要把 <code>nums</code> 中所有的 <code>val</code> 都刪掉，然後返回剩餘陣列的長度。條件是必須在 O(1) 的記憶體實現。</p>
<p>在 python 中，可以透過 <code>list.remove(val)</code> 刪除 <code>list</code> 中的 <code>val</code>。由於 <code>list.remove()</code> 只能刪除第一個出現的 <code>val</code>，因此，透過 while 迴圈來刪除所有 <code>val</code>，同時透過 has_element 這個 tag 來判斷 <code>nums</code> 中是否還有 <code>val</code>，如果已經全部刪除的話，則結束迴圈。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        has_element = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> has_element:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                nums.remove(val)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                has_element = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://snakepowerpoint.github.io/2021/08/29/remove-element/" data-id="cktzmt5gg000jhxqacrfbd53k" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/easy/" rel="tag">easy</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-do-right-now" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/do-right-now/">結果，立刻去做的人得到一切</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/07/18/do-right-now/" class="article-date">
  <time datetime="2021-07-18T16:07:39.000Z" itemprop="datePublished">2021-07-19</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E6%9B%B8%E6%91%98/">書摘</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <img src="/2021/07/18/do-right-now/do-right-now-cover.jpeg" class="">


<p>&nbsp;</p>
<h3 id="工作、財富、夢想……"><a href="#工作、財富、夢想……" class="headerlink" title="工作、財富、夢想……"></a><em>工作、財富、夢想……</em></h3><h3 id="只要-10-秒鐘-，一切不再遙不可及！"><a href="#只要-10-秒鐘-，一切不再遙不可及！" class="headerlink" title="只要 10 秒鐘 ，一切不再遙不可及！"></a><em>只要 10 秒鐘 ，一切不再遙不可及！</em></h3><h3 id="只要-10-秒鐘，你就能擺脫拖延的人生，成為立刻付諸行動的人。"><a href="#只要-10-秒鐘，你就能擺脫拖延的人生，成為立刻付諸行動的人。" class="headerlink" title="只要 10 秒鐘，你就能擺脫拖延的人生，成為立刻付諸行動的人。"></a><em>只要 10 秒鐘，你就能擺脫拖延的人生，成為立刻付諸行動的人。</em></h3><p>&nbsp;</p>
<p>你是不是常常訂好了目標，但卻一直無法展開行動？</p>
<p>你是不是常常覺得時間還很多，不如先耍廢一下？</p>
<p>你是不是總是要拖到最後一刻，才開始焦慮地工作？</p>
<p>本書提供你一些小撇步，教你如何提升自己的行動力，擺脫拖延的習慣！</p>
<p>讀完本篇，你將會知道：</p>
<ul>
<li><p>決定你要不要立刻去做一件事情的，不是動力，而是「心情」</p>
</li>
<li><p>心情是可以控制的，只要把心情控制在對的狀態下，就能有行動力</p>
</li>
<li><p>透過轉換視角，可以幫助自己理出行動的頭緒，降低行動門檻</p>
</li>
<li><p>提升周遭的人的效率，讓自己的效率再上一層樓</p>
</li>
</ul>
<p>&nbsp;</p>
<h3 id="書目資訊"><a href="#書目資訊" class="headerlink" title="書目資訊"></a>書目資訊</h3><p>書名：結果，立刻去做的人得到一切<br>作者：藤由達藏<br>譯者：李璦祺<br>出版社：方智<br>出版日期：2016/12/01</p>
<p>&nbsp;</p>
<h3 id="作者介紹"><a href="#作者介紹" class="headerlink" title="作者介紹"></a>作者介紹</h3><p><strong>藤由達藏</strong>，Seminar room gonmatus 負責人，夢想實現聲援家（心理教練），以「人有無限潛在可能」為座右銘，提供各行各業人士，面對面的教練學（Coaching）指導、提高原動力的培訓課程，以及創造力和能力開發的工作坊，服務對象廣泛，包括作家、創作歌手，經營者、創業家、商務人士、學生、親子等等。</p>
<p>1991年早稻田大學畢業後，進入文具與辦公室家具的製造商PLUS任職。將教練學導入工會活動中，擔任工會成員的研討會講師。多次應東京都立高中家長會、業界團體之邀，進行演講。</p>
<p>2013年9月，以教練身分自立門戶。以平本Akio為代表董事的Team Flow公司的教練學為核心，統合各種心理技巧、武術、冥想法、工會活動、藝文美術音樂創作等經驗，建立起一套重視「心情與視角之轉換」的獨創方法論。其幽默而富有熱情的講述方式，簡單易懂且充滿親和力。</p>
<p>為提升緬甸與日本之間的友好與發展，正準備在緬甸設立教練學校。</p>
<p>&nbsp;</p>
<h3 id="譯者介紹"><a href="#譯者介紹" class="headerlink" title="譯者介紹"></a>譯者介紹</h3><p><strong>李璦祺</strong>，輔大翻譯所碩士課程修畢，現為專職日文譯者。興趣廣泛，尤其酷愛文字、貓咪與知識。視翻譯為天職，期許自己用文字打開疆界，連結作者與讀者的世界。譯有《由我來改變！：全球企業爭相效法！谷底翻身的女社長痛哭戰記》、《結果，立刻去做的人得到一切》等書。</p>
<p>&nbsp;</p>
<h3 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h3><p>前言　採取行動的人，才能改變人生</p>
<p>第一章　十種習慣讓人無法立刻行動　【了解】</p>
<p>第二章　十秒內行動的人這樣的思考　【學習】</p>
<p>第三章　十秒心智轉變法，讓你成為立刻行動的人　【改變自己】</p>
<p>第四章　做出成果！影響他人的十秒轉變法　【改變周遭】</p>
<p>第五章　十秒鐘接近人生目標的思考與行動秘訣　【改變人生】</p>
<p>&nbsp;</p>
<h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>這是一本很不錯的<strong>工具書</strong>，提供很多讓人「立刻行動」的實用技巧。此外，本書還點出一般人對於行動力的誤解，說明人的行動力不是來自於想完成某件事情的「動機」，而是來自於「<strong>心情</strong>」。</p>
<blockquote>
<p><strong>拖延的原因</strong></p>
</blockquote>
<p>一開始，作者先說明為什麼我們很難立刻去做某件事情，這是因為我們有一些<strong>阻礙行動思考的習慣</strong>，也就是說，雖然我們知道自己想做什麼，知道什麼事情非做不可，但一旦要執行時，就會對自己的行動踩煞車。</p>
<p>很多人可能都沒注意到自己的這個習慣，因此，想要成為立刻採取行動的人，就要先<strong>認識自己的思考習慣</strong>。這些阻礙行動思考的習慣，不外乎是由以下幾點因素所形成：</p>
<p>&diams; 對時間的掌控能力不好</p>
<p>我們在剛開始執行計畫的時候，常常會因為距離期限還有N小時、N天、N個月，就覺得時間還很充裕，不用馬上做。但是，這種「<strong>覺得時間還很多</strong>」的錯覺，是因為自己對於整個計畫沒有全盤的了解，導致錯估了計畫時間軸的結果。而等到最後真的快來不及的時候，還會因為要做的事情太多，而發生<strong>腦袋凍結</strong>，陷入無法思考的窘境。</p>
<p>例如，學期初的時候總覺得時間還很多，不用急著念書，等到快要期中考的時候，才發現有一大堆科目沒念，一時之間也不知道要從哪開始念起。這種情形就是在一開始錯估了期中考的難易度，以及自己念書所需的時間，才會出現一再拖延的情形，導致最後不得不臨時抱佛腳。</p>
<p>&diams; 身處在錯誤的情緒下</p>
<p>決定我們要不要去做某件事情的因素，其實不是想完成某件事情的動機，而是當下的<strong>心情</strong>。例如，我們有時明明想著「要減肥」、「要認真」、「要做一些有意義的事情」，心裡雖然有想做這些事情的動機，但卻常常為了一點小事就失去幹勁，或是突然覺得做起來好麻煩。這並不是因為我們不想做那些事情，而是因為當下的心情不適合做這些事情。回想一下自己專注在做某件事情的時候，心情是不是常常是有幹勁的呢？</p>
<blockquote>
<p><strong>心情</strong></p>
</blockquote>
<p>既然心情才是驅動我們去做某件事情的原動力，那麼盡量讓自己保持在一個有幹勁的情緒下，就能讓自己擁有很強的行動力。但是，要怎麼讓自己保持在有幹勁的情緒呢？首先，我們必須先認識到：</p>
<p><code>心情是可以控制的</code></p>
<p>現在，試著回想一件讓你覺得很氣憤的事情，可以是很久以前的事情，也可以是最近發生的事情。例如：某人欠你錢不還、路上突然有三寶衝出來、雙11沒搶到優惠、政客睜眼說瞎話等等。</p>
<p>是不是覺得有點生氣？</p>
<p>原本你在閱讀讀本篇文章的時候，應該是沒有什麼事情讓你感到生氣，但經由回想，你還是感受到憤怒。事實上，不只是憤怒的情緒，大部分的情緒都可以透過一些手法來生成或抑制。作者在書中提供了幾個<strong>重整心情</strong>的方法：</p>
<ul>
<li><p>利用<strong>表情、動作、話語</strong>來切換心情</p>
</li>
<li><p>透過<strong>回憶</strong>改變心情</p>
</li>
<li><p>靠<strong>想像</strong>改變心情</p>
</li>
</ul>
<p>例如，我們可以透過大笑、誇張地放生大笑，讓自己憑空得到快樂；我們也能透過回想一些有趣的事情，讓心情感到愉悅；就算沒有回憶，我們也能透過想像一些有趣的事情或畫面，讓自己感到快樂。</p>
<p><strong>環境</strong>也是影響心情的重要因素，例如在自己的工作、學習環境擺設一些自己喜歡的裝飾品，把周遭打造得像自己的家，就能讓自己維持好心情。</p>
<p>總而言之，找到適合自己的方法來調適心情，把情緒維持在一個適合做事的狀態，就能大大提升自己的行動力。</p>
<blockquote>
<p><strong>轉換視角</strong></p>
</blockquote>
<p>除了將自己的心情控制在具有高行動力的狀態，另一個提升行動力的重點是<strong>視角轉換</strong>。所謂的視角轉換，就是：</p>
<p><code>對於同一件事情，利用不同的觀點、立場、條件去思考。</code></p>
<p>透過視角轉換，就能避免在單一視角下可能會遇到的盲點。當你能夠從不同的面相來思考同一件事情的時候，就能對該件事情有越全面的了解，也就越知道該怎麼去執行，降低錯估的機率。</p>
<p>例如上述「覺得時間還很多」的例子，有很大一部份原因是只用單一視角去評估。如果在期初的時候，就能夠站在「期中的自己」去思考，或是從不同的角度去看待目前的時間規劃，就比較容易判斷下一步該怎麼走。一旦有了頭緒，就能大幅地降低行動的門檻，提高行動力。</p>
<p>書中還有討論其他阻礙行動思考的習慣，這邊就不多做介紹，只舉其中一個例子－－<strong>過分想要迴避風險</strong>。</p>
<p>做任何事情都有可能失敗，而害怕失敗的想法會讓人想要逃避，導致我們不去做該做的事情。廣義地說，這裡的風險還包括一些不想面對的事物，例如某個不好的經驗或回憶，或者在做某件事情時，所感受到的痛苦感。因為不想面對這些經驗，所以產生抗拒，並選擇逃避，最後導致拖延的現象。</p>
<blockquote>
<p><strong>改變周遭</strong></p>
</blockquote>
<p>除了提升自己的行動力，我們還必須影響他人。本書提到，生活中很多事情往往不是我們自己就可以完成，需要藉助他人的幫忙，如果能讓別人也具備很強的行動力，就能進一步提升自己的效率。</p>
<p>那要如何提升他人的行動力呢？最簡單的方法不外乎是<strong>讚美</strong>他人，讓別人有自信，就能提高他們的行動力。不過，本書認為更有效的做法不是讚美，而是<strong>傳達個人訊息</strong>。所謂傳達個人訊息是指：</p>
<p><code>將自己所觀察到或感覺到，對方表現好的、了不起的、或令你欣賞的地方，把它告訴對方。</code></p>
<p>透過傳達這種屬於個人觀察所得出來的讚美，會比單純說「你很棒」還要來得具體且有效，也更能激發對方的潛能，提升對方的行動力。</p>
<blockquote>
<p><strong>設定目標</strong></p>
</blockquote>
<p>最後，空有行動力還不夠，最重要的是<strong>擁有自己的目標</strong>，才能改變人生。試著問自己：</p>
<p><code>如果沒有任何限制的話，你希望自己在哪裡做著什麼事情？</code></p>
<p>每天持續問自己這個問題，你就會越來越清楚自己的人生目標和意義，也會越來越明白那些讓你感到興奮雀躍的願景，以及永不妥協的人生價值觀。</p>
<p>&nbsp;</p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>這本書的作者文筆流暢，翻譯也翻得很順，在章節的安排上非常有架構，循序漸進，引導讀者了解拖延的原因，並分析行動力的本質，然後提出解決拖延的辦法，提升行動力。最後還順勢點出一些人生哲理以及人際關係的課題，不過只佔一小部分。</p>
<p>雖然章節的安排十分嚴謹，但每個章節內部的架構編排相對零散，在內容的陳述上，多半是由一些例子所組成。例如第一章在講為什麼人會有拖延的現象時，並不是用一個系統性的架構去解釋成因，而是舉很多可能會導致拖延習慣的例子。這些例子彼此之間不一定有前後的順序關係，也不一定有因果關係，讀起來會覺得缺乏系統性。此外，書中所舉的例子並非完全和讀者的經驗相吻合，所以有些地方讀起來可能會覺得沒有說服力。</p>
<p>不過整體而言，這些「沒感覺的例子」並不會造成太嚴重的理解障礙，也不會影響書中整體想要傳達的觀念，以及邏輯的堆疊與推演。</p>
<p>對於有拖延習慣的人來說，這本書可以提供你一些有效的方法來提升自己的行動力。不過，要擺脫拖延的習慣，最重要的事情是能夠<strong>察覺自己</strong>正在拖延的行為，分析自己拖延的原因，然後再從書中找出對應的解決辦法，實際去執行，才能真正解決拖延的問題。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://snakepowerpoint.github.io/2021/07/18/do-right-now/" data-id="cktzmt5g80007hxqa28dob79y" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%83%E7%90%86%E5%AD%B8/" rel="tag">心理學</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B9%E6%B3%95%E8%AB%96/" rel="tag">方法論</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-mit-comm" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2021/07/04/mit-comm/">MIT最打動人心的溝通課</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/07/04/mit-comm/" class="article-date">
  <time datetime="2021-07-04T14:57:35.000Z" itemprop="datePublished">2021-07-04</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E6%9B%B8%E6%91%98/">書摘</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <img src="/2021/07/04/mit-comm/mit-comm-cover.jpg" class="">


<p>&nbsp;</p>
<h3 id="書目資訊"><a href="#書目資訊" class="headerlink" title="書目資訊"></a>書目資訊</h3><p>書名：MIT最打動人心的溝通課<br>作者：艾德．夏恩（Edgar H. Schein）<br>譯者：徐仕美、鄭煥昇<br>出版社：天下文化<br>出版日期：2014/12/26</p>
<p>&nbsp;</p>
<h3 id="作者介紹"><a href="#作者介紹" class="headerlink" title="作者介紹"></a>作者介紹</h3><p><strong>艾德．夏恩Edgar H. Schein</strong>，MIT史隆管理學院退休榮譽教授，被尊為管理學界的企業文化大師，也是當代組織心理學的創建者之一。</p>
<p>夏恩的研究備受讚譽，他的《組織文化與領導》（Organizational Culture and Leadership）是分析組織與文化中最具代表性的著作之一，另有多本組織發展領域的重要著作，包括《組織心理》、《過程諮詢》等。</p>
<p>夏恩於1952年取得哈佛大學社會心理學博士，自1956年起開始在MIT擔任教職，任教近半個世紀。曾榮獲美國訓練管理者協會（ASTD）頒發職場學習類別的終身成就獎；國際管理學會頒發「Everett Cherrington Hughes Award」，肯定他在生涯研究、主管領導力發展上的貢獻。</p>
<p>夏恩於2011年遷居至加州帕羅奧圖展開退休人生，並持續寫作，本書是夏恩集五十年心得之大成。</p>
<p>&nbsp;</p>
<h3 id="譯者介紹"><a href="#譯者介紹" class="headerlink" title="譯者介紹"></a>譯者介紹</h3><p><strong>徐仕美</strong>，台灣大學植病所碩士，曾任遠哲科學教育基金會編輯、天下文化科學編輯，目前是自由譯者與特約編輯。</p>
<p><strong>鄭煥昇</strong>，師大翻譯研究所口譯組碩士。譯作有《TED Talk 十八分鐘的祕密》、《跟任何人都可以聊得來》等。</p>
<p>&nbsp;</p>
<h3 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h3><p>推薦序 問題的力量 劉鏡清</p>
<p>前言 有效溝通的關鍵</p>
<p>第一章    當下的謙遜：建立關係的第一步</p>
<p>第二章    引導別人打開心房：八個個案分析</p>
<p>第三章    謙遜提問怎麼問？展現好奇與關心</p>
<p>第四章    要贏的不失禮：讓人困窘，後患無窮</p>
<p>第五章    地位、階級、角色造成的心理障礙</p>
<p>第六章    認識內在的四個自我：避開溝通過程的心理偏誤</p>
<p>第七章    從調整心態到掌控局面：讓人心服口服的領導人</p>
<p>&nbsp;</p>
<h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>本書主要在探討什麼是有效的溝通，以及如何達到有效的溝通，而方法就是「<strong>謙遜提問</strong>」。</p>
<blockquote>
<p><strong>有效溝通的關鍵</strong></p>
</blockquote>
<p>良好的溝通始於<strong>互信</strong>，而互信始於謙遜提問。從心理學的角度來看，人們只有在開放、互相信賴的氛圍下，才會吐露真言。因此，要達到有效的溝通，必須先營造互相信賴的氛圍。為了達到這個目的，我們必須與他人建立關係，而建立關係最好的方式是開口「提問」，更精確來說，是「謙遜提問」。</p>
<blockquote>
<p><strong>引導別人打開心房</strong></p>
</blockquote>
<p>我們身處在鼓勵「<strong>說</strong>」的主流文化中，因而不善於「<strong>提問</strong>」。但是，「說」並不容易建立關係，因為「說」本身有上對下的意涵，「說」意味著有件事你應該知道，但你不知道，所以我說給你知道。相反的，「問」是將自己的姿態擺低，它所傳達的訊息是我承認自己的無知，並且我願意投入心力向你請教，這種放低姿態的行為，較容易使他人卸下心防，進而建立互信的關係。</p>
<p>信任關係之所以能夠建立，是因為我先打開了自己的心房，而對方並沒有趁此機會欺負我，於是我開始對對方產生了某種程度的信任，相對的，對方也會開始慢慢信任我，因為提問代表我關注對方，而且我很仔細聆聽對方提供的答案。</p>
<blockquote>
<p><strong>謙遜提問</strong></p>
</blockquote>
<p>問有分好幾種，如果只是單純的提問，或是表面上看起來是問，但實際上是在說的話，都無法做到有效的溝通，只有謙遜提問才能真正達到有效的溝通。所謂的謙遜提問，是指<strong>承認自己的無知，不帶任何偏見的虛心求教</strong>，它源自於我們對別人的關注與好奇心，是一種想要建立關係的渴望。</p>
<p>謙遜提問所指的「謙遜」有分三種情況，一種是<strong>基本的謙遜</strong>，這是基於傳統社會文化所產生的一種必然的、天生的謙遜，例如血統、種族等。例如在某些文化中，當人們遇到比自己優越的血統時，會表現出禮貌的行為。另一種謙遜是<strong>選擇性的謙遜</strong>，這種謙遜指的是人們對於成就高過自己的人，所表現出來的敬畏、欽佩或羨慕的行為，例如我們會對諾貝爾獎得主或奧運金牌得主展現敬意。第三種謙遜是<strong>當下的謙遜</strong>，指的是當我依賴你時的內心感受。這種謙遜展現出此刻我的狀態在你之下，因為你掌握了我想完成目標所需、但欠缺的知識或技能。當下的謙遜是謙遜提問中最重要的謙遜形式，大多數時候，我們都是基於當下的謙遜來進行謙遜提問。</p>
<blockquote>
<p><strong>因地制宜的謙遜提問</strong></p>
</blockquote>
<p>在不同的時機、場合和狀況下，會有不同形式的謙遜提問，大致上可分成診斷式提問、對質式提問、過程導向式提問。<strong>診斷式提問</strong>是一種引導對話走向的提問方式，透過提問，將話題牽引到提問者感興趣的事情上，例如詢問對方的感受與反應、起因與動機、行動導向、系統性問題等。它本質上並不是單方向的「說」，而是透過診斷提問來完成任務。<strong>對質式提問</strong>會加入自己的想法，但仍維持問題的形式。它可以再細分為詢問對方的感受、動機、行動導向等，雖然很容易流於對別人指指點點，但只要動機是出於幫忙對方，仍然可以用來建立信任關係。<strong>過程導向式提問</strong>會先暫停討論的內容，把焦點聚集在當下的互動上，例如詢問對方：「我剛才是不是問太多了？」，這種提問方式可以將彼此拉回對話本身，是破解尷尬的利器，但較難拿捏尺度。</p>
<p>無論是何種謙遜提問，在建立互信關係的過程中，都會遇到難題。只要保持誠心幫助對方的心態，就能一一化解。相反的，如果內心始終帶著高人一等的好勝心態，假裝出謙遜的樣子，終究無法使人信服。作者建議，如果總是忍不住想「說」，那就記住：<strong>聽者無心，那建議就白給了。</strong></p>
<blockquote>
<p><strong>地位、階級、角色所造成的心理障礙</strong></p>
</blockquote>
<p>不論是哪個文化，人們從小就被教導在不同的場合中，應該要如何感受及表現，這種因社會文化所形成的地位、階級或角色上的差異，會對人們造成心理障礙，阻礙謙遜提問。例如上司講話的時候，下屬就應該要專心聽，不得提出問題。為了避免這些社會規範所造成的影響，作者建議可以用<strong>個人化</strong>的方式與他人建立關係，也就是把他人視為完整的個人，而非只是執行任務的過程中所扮演的角色，這樣就能透過謙遜提問，與他人建立比任務導向更深厚的關係。</p>
<blockquote>
<p><strong>內在自我</strong></p>
</blockquote>
<p>除了社會規範，內在的四個自我也會影響溝通，造成溝通的複雜性。內在的四個自我源自於社會心理學中，幫助我們自我認識、接納與成長的周哈里窗（Johari window），根據理論，我們可以透過「自己掌握的訊息」和「別人能掌握的訊息」，將自己分割成四個範疇，包括<strong>隱藏自我、開放自我、未知自我、盲目自我</strong>。這些自我會影響日常的溝通，例如開放自我是自己和他人都知道的自我，這種自我代表的是我們願意且知道可以跟陌生人暢談的話題；而隱藏自我是自己知道但願意透露的事情。在建立關係的過程中，我們會遊走在不同的自我中，並思考要隱藏或揭露自己到什麼程度。</p>
<blockquote>
<p><strong>注意心智偏誤與知覺扭曲</strong></p>
</blockquote>
<p>人類的大腦會產生<strong>心智偏誤</strong>和<strong>知覺扭曲</strong>，若我們在對話的過程中，因為某些偏誤而誤判情勢，或者不知道什麼行為比較得體時，就無法表現出恰當的謙遜。因此，如果想讓謙遜提問發揮效果，就必須深究這些偏誤和扭曲。</p>
<p>人類複雜的心理過程可以濃縮成一個簡化的模型，由<strong>觀察（observation）、反應（reaction）、判斷（judgment）、干預（intervention）</strong>四個過程所組成，具體來說，人類會先透過觀察來蒐集環境資訊，再根據觀察結果產生相對應的反應，例如產生情緒。接著，人類會分析和判斷這些資訊，並依照理性與感性思維去策畫行動，然後實際執行（干預）。如果在第一步驟（觀察）中，就盡可能地蒐集正確的資訊並過濾偏誤，就能避免心智偏誤和知覺扭曲。</p>
<p>最後，作者總結，若要成為一個讓人心服口服的領導人，就要先明白領導始於關係的建立，而適時的謙遜提問可以啟動對話，而對話可以啟動關係的建立。因此，我們應該要努力充實自我，擴展自己的感知與洞察力；多自省，並向自己提問，然後嘗試用謙虛提問來掌握局面。</p>
<p>&nbsp;</p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>這本書的章節架構編排得相當好，前言就先總結了本書的內容，讓讀者快速瞭解內容大綱。在接下來的章節中，作者先帶出謙遜提問的基本觀念，但忽略細節不說，而是透過一些個案分析，先讓讀者體會謙遜提問的價值，然後才開始詳細解釋謙遜提問，並說明在不同文化及社會規範下，需要因地制宜使用謙遜提問。書末，作者引用心理學的理論來解釋人腦的運作模式，說明人的心智可能會產生偏誤，因此建議讀者應該努力提升自己的感知能力，以便擷取環境中正確的資訊，再選擇適當的社交行為來和他人打交道。</p>
<p>雖然這本書的架構編排得很好，但也有一些缺點。首先，作者的論述能力差強人意，常常用很長的篇幅來講一個簡單的概念，而且還講不清楚。例如作者在解釋謙遜提問的形態時，先把提問分成四種類型，分別是謙遜提問、診斷式提問、對質式提問、過程導向式提問，這種分類法會讓人以為謙遜提問和其他三種提問不同，但文中又多次提及這些提問算是謙遜提問的變形，讓人搞不清楚到底這些提問是不是謙遜提問的一種。</p>
<p>其次，這本書的說服力偏低，主要是因為書中所舉的案例大多不是生活中常見的情境，無法讓人感同身受。例如其中一個案例是作者在擔任系主任時，遇到系上電話費暴增的問題。這種案例比較像是特定的情境，而非一般化的情形。而且，作者在解決問題的過程中，所用到的謙遜提問形式也不太能用在一般的狀況，讀起來不太有說服力。</p>
<p>最後，這本書有非常多重複論證的地方，190頁的內容，大概只有40-50頁是新的資訊，讀起來有點浪費時間的感覺。</p>
<p>整體而言，本書所要闡述的觀念並不多，也不難理解。對於想要增進溝通技巧的人來說，這本書可以讓你獲得一些有關溝通的理論基礎，同時提供你一種有效的溝通技巧。對我而言，我印象比較深刻的地方是：「問」是比「說」更有效的溝通方式。這有點違反直覺，但看完解釋後，又覺得十分有道理。我認為可以試著將謙遜提問納入溝通的百寶箱中，選擇適當的時機使用它，應當就能獲得不錯的效果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://snakepowerpoint.github.io/2021/07/04/mit-comm/" data-id="cktzmt5gd000dhxqa5piaej2w" class="article-share-link">
        Share
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%83%E7%90%86%E5%AD%B8/" rel="tag">心理學</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B9%E6%B3%95%E8%AB%96/" rel="tag">方法論</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%9D%E9%80%9A/" rel="tag">溝通</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一頁</a>
  </nav>
  
</section>
</div>

    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>Rahul&#39;s Blog &copy; 2021</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Rahul&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>