<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>在 Hexo 插入圖片標題</title>
    <url>/2021/10/24/hexo-ocean-img-caption/</url>
    <content><![CDATA[<p>最近在寫文章的時候，突然發現需要替圖片補上標題，上網查了一下，聽說 markdown 可以透過下面的語法，直接幫圖片插入標題：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](path_to_image)</span><br><span class="line">*image_caption*</span><br></pre></td></tr></table></figure>

<p>不過我自己試了一下發現不行，由 Hexo 渲染的 markdown 文章並無法直接插入圖片標題。繼續爬文後，找到了另一個方法，而且做法相當簡單！</p>
<span id="more"></span>

<h3 id="步驟一"><a href="#步驟一" class="headerlink" title="步驟一"></a>步驟一</h3><p>首先先安裝 hexo 套件，在 <code>cmd</code> 中輸入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-image-caption</span><br></pre></td></tr></table></figure>

<h3 id="步驟二"><a href="#步驟二" class="headerlink" title="步驟二"></a>步驟二</h3><p>接著在 hexo 的 config 中加入以下資訊：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># add caption for iamges</span><br><span class="line">image_caption:</span><br><span class="line">  enable: true #false to disable</span><br><span class="line">  class_name: #if you wanna customize the style for the caption,you can assign a class name, default is &#x27;image-caption&#x27;</span><br></pre></td></tr></table></figure>

<p>基本上這樣就大功告成了，往後只要在 markdown 文章中輸入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![caption](img_file_name.jpg)</span><br></pre></td></tr></table></figure>

<p>就能幫圖片插入標題啦！</p>
<h3 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h3><p>這個方法美中不足的地方是，標題沒辦法置中，爬文發現要另外在文章的 css 中加入一些設定，才能讓圖標置中。以我使用的 ocean 主題為例，在 <code>ocean/source/css/_partial/articles.styl</code> 中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.article .image-caption &#123;</span><br><span class="line">    margin: auto;</span><br><span class="line">    display: block;</span><br><span class="line">    text-align: center;</span><br><span class="line">    width: 80%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣就能讓圖片置中啦了，是不是很簡單！</p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul>
<li><p>hexo-image-caption <a href="https://github.com/wayou/hexo-image-caption">https://github.com/wayou/hexo-image-caption</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll">https://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll</a></p>
</li>
<li><p><a href="https://www.dazhuanlan.com/jokerissb/topics/1160083">https://www.dazhuanlan.com/jokerissb/topics/1160083</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>程式</category>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo, ocean</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 11. Container With Most Water</title>
    <url>/2021/10/19/container-most-water/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.</p>
<p>Notice that you may not slant the container.</p>
<p>Example 1:</p>
<blockquote>
<p>Input: height = [1,8,6,2,5,4,8,3,7]<br>Output: 49<br>Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
</blockquote>
<span id="more"></span>

<p>解題思路：</p>
<p>暴力解法是用 for 迴圈遍歷任二條線所圍出來的面積，結果可能會受到時間限制無法通過測試。</p>
<p>另一種解法是雙指針搭配貪婪演算法。首先把指針放在左右端點，然後計算這二個端點所圍出來的面積，並更新目前記錄到的最大面積。接著，剔除高度比較矮的那個端點，把指針往對應的方向往前移動一格，例如左邊指針對應的高度比右邊指針對應的高度矮的話，則左邊的指針往右邊移動一格。</p>
<p>重複上述的動作，每次都紀錄最大的面積，然後再踢掉最矮的那條線，去找更高的線來圍出更大的面積，直到二個指針相遇。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (r - l) * <span class="built_in">min</span>(height[l], height[r]))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> height[l] &lt;= height[r]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程式</category>
        <category>LeetCode</category>
        <category>Pointer</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 17. Letter Combinations of a Phone Number</title>
    <url>/2021/09/28/letter-com-num/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p>Example 1</p>
<blockquote>
<p>Input: digits = “23”<br>Output: [“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p>
</blockquote>
<span id="more"></span>

<p>題目給定一組數字和英文字母的對照表，問一組 digits 中，所有可能的字母組合，例如 2 和 3 分別對應 abc 及 def，則 <code>23</code> 所有可能的組合就是 <code>[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</code>。</p>
<p>這是一個滿好的練習題，可以練習到很多演算法的基本觀念，包括遞迴、DFS (depth-first search)、對各種資料結構的基本操作等。</p>
<p>本題的解法是透過 tree 做 search，概念上可以想像成先將 digits 中所有數字放到 tree 的各階層，例如 <code>23</code> 有二個數字，2 放 root，3 放第一層。其中，2 有 a, b, c 三種可能性，所以在 tree 上 2 有三個 branch，分別接到三個同為 3 的 node，每個 branch 分別代表 a, b, c。同理，3 有 d, e, f 三種可能性，所以這三個 node 各自再接出三個 branch 出來，形成九個 leaf，這九個 leaf 就是 <code>23</code> 這個 digits 所有可能的字母組合。</p>
<p>其中一個解法是 DFS，從 root 開始，先往左直接探到最深層的 leaf，得到一組答案後，往回一個 node，重複上述的操作，最後就能得到所有的 leaf。</p>
<p>具體來說，先定義好各個 digits 對應的字母，在樹狀結構下，每一層數字有其對應的字母，如果用 DFS 來解的話，會直探最後一個 digits 對應的所有字母，然後回到上一層的第二個字母，再去配對最後一層所有的字母。這裡透過 <code>cur</code> 紀錄當前深度下的數字所對應的字母，<code>l</code> 表示當前層數，將所有資訊輸入遞迴函數 <code>dfs</code> 中。</p>
<p>遞迴函數 <code>dfs</code> 一開始會先判斷遞迴的中斷條件，如未滿足，則繼續跑遞迴的主邏輯區塊。一旦中斷條件滿足，<code>dfs</code> 就會把目前所有的字母組合在一起，然後加到結果 <code>ans</code> 中。持續重複以上動作，最後就能得到答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        </span><br><span class="line">        mapping = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line">        cur = [<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits))]</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(digits, cur, <span class="number">0</span>, mapping, ans)  <span class="comment"># start recursive</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, digits, cur, l, mapping, ans</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l == <span class="built_in">len</span>(digits):  <span class="comment"># condition to stop recursive</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; <span class="number">0</span>:</span><br><span class="line">                ans.append(<span class="string">&quot;&quot;</span>.join(cur))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> mapping[<span class="built_in">int</span>(digits[l])]:  <span class="comment"># main recursive</span></span><br><span class="line">            cur[l] = c</span><br><span class="line">            self.dfs(digits, cur, l+<span class="number">1</span>, mapping, ans)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程式</category>
        <category>LeetCode</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>看準位置，只賺不賠：掌握投資11大關鍵理論，買股不受傷</title>
    <url>/2021/09/12/stock-position/</url>
    <content><![CDATA[<img src="/2021/09/12/stock-position/stock-position.jpg" class="">


<p>&nbsp;</p>
<h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>本書是郭泰投入股市30餘年的心得彙整，作者總結了自己數十年來的操盤經驗，以及20本經典投資書籍的內容，歸納出11個投資的經典理論，包含價值理論、循環理論、位置理論、時間理論、籌碼理論、棄取理論、順勢理論、停損理論、抱股理論、主力理論、選股理論。</p>
<p>這些理論中，最重要的就是<strong>位置理論</strong>，其他理論基本上都是基於位置理論發展而成。想要在股市中賺錢，就必須要低買高賣，而位置理論就是在告訴投資人，股市有分<strong>頭部</strong>和<strong>底部</strong>，看清楚底部的位置後，大膽買進，接著長抱股票，等到頭部來臨時，再一舉獲利了結，這就是股票投資的聖盃。</p>
<p>底下我總結幾個我認為比較重要的理論：</p>
<span id="more"></span>

<blockquote>
<p><strong>價值理論</strong></p>
</blockquote>
<p>價值理論又稱為<strong>價值投資（value investing）</strong>，是由美國著名的基金經理人<strong>班傑明‧葛拉漢（Benjamin Graham）</strong>所提出，這套理論的核心思想是：<strong>任何股票不論股價怎麼漲跌，從長期來看，股價必定會反映其真實的價值</strong>。因此，當一間長期穩定獲利的公司，其股價跌到淨值以下時，且又沒有其他負面因子影響時，那麼目前的股價就是低估了，投資人應該要大膽買進。</p>
<p>價值投資非常適合散戶，因為散戶擁有的資訊比法人少很多，所以只要嚴守價值理論的原則去購買股票，就比較不容易吃虧。股神巴菲特（Buffett）其實就是價值投資之父班傑明‧葛拉漢的嫡傳弟子，而巴菲特所擁有的波克夏‧海瑟威公司，就是透過這種價值投資法，長年在股市獲得巨大的利潤。而巴菲特厲害的地方就在於找出目前被市場低估的股票，然後傾全力投入資金，並且長期持有。</p>
<blockquote>
<p><strong>循環理論</strong></p>
</blockquote>
<p>股市和景氣息息相關，所以股價自然也和景氣一樣具有<strong>循環</strong>的現象，這就是循環理論的核心思想。</p>
<p>根據美國的股市天才艾略特（Elliott）所提出的八波段循環理論，股價在一個完整的走勢中，會呈現八個波段走法，而當八個波段走完後，會開始另一個八波段的走勢，不斷循環下去。</p>
<img src="/2021/09/12/stock-position/eight-wave.JPG" class="">

<p>具體而言，<strong>八個波段包含三個主要的上升階段（第一、三、五波），以及二個主要的下跌階段（第六、八波）。</strong>第一到第五波段是多頭行情，其中，第一波段又稱為初升段，第三波段為主升段，第五波段為末升段，而二、四波段的下跌是回檔整理。另一方面，第六到第八波段是空頭行情，其中，第六波段為初跌段，又稱為A波，第七波段是反彈逃命波，俗稱B波，而第八波段為主跌段，又稱為C波。</p>
<p>波浪理論不一定能完全解釋歷史股價，有時多頭行情只有二波（一、三波段），接著就是空頭行情。此外，根據艾略特的研究，八波段中還會隱含一些小波段，總共可以分為34個小波，甚至144個小小波。不過這些小波、小小波的參考意義不大，主要還是以八波段為主。</p>
<p>無論如何，歷史告訴我們股價會周而復始地循環，這背後的邏輯其實就是人類追求財富的過程，也就是買進股票、追價、一直到獲利了結的過程，而這就是循環理論所要點出的核心概念。</p>
<blockquote>
<p><strong>位置理論</strong></p>
</blockquote>
<p>基於循環理論，我們可以從八波段的循環走勢中，判斷大盤或個股的位階，並將股價分為底部、頭部及中部。想要在股票市場中賺錢，就必須低買高賣，所以我們要<strong>在底部大膽地分批買進</strong>，然後<strong>在頭部果斷地分批賣出</strong>。至於要如何判斷目前股價是處於什麼位置，作者指出，台股每一次循環來到底部區時，都會出現一些訊號，例如：月k線走完八波段且隨後出現月紅k線、月成交量大幅萎縮、融資餘額的跌幅大於大盤的跌幅、國安基金護盤等。</p>
<p>當然，要精準抓出底部仍然十分困難，我們可以退而求其次，在次底部區（第二波段）買進股票，再靜待頭部區的到來，獲利了結。作者指出，台股每一次來到頭部區時，都會出現一些訊號：月k線走完多頭行情的五個波段、月KD在80附近形成死亡交叉、股價跌破上升趨勢線或年線等。</p>
<p>當越多的指標同時出現，就代表頭部或底部的訊號越明顯，投資人可以依照這些訊號做對應的操作。</p>
<blockquote>
<p><strong>籌碼理論</strong></p>
</blockquote>
<p><strong>股市中唯一的真實資訊是成交量</strong>，因為成交量是多方或空方用錢堆砌起來的，不可能是假的。正所謂新手看價，老手看量，股價通常是主力誘多或誘空的工具，參考價值較低。一般來說，成交量是股票的先行指標，多頭行情若要發動，必須要<strong>量價配合</strong>，也就是價漲量增。反之，如果出現<strong>量價背離</strong>的情況，則股價容易轉弱，形成空頭行情。因此，我們可以透過成交量來判斷大盤或個股的走勢。</p>
<p>作者指出，底部區出現時，成交量會有以下幾種變化：</p>
<ul>
<li><p>月成交量大幅萎縮</p>
</li>
<li><p>融資餘額的跌幅大於大盤的跌幅</p>
</li>
<li><p>從週成交量看出已經打底成功</p>
<p>一般而言，當股價從高檔下殺時，每週成交量的總和，就是上檔套牢區的賣壓；而當股價來到底部橫向盤整時，就是在消化套牢賣壓。當盤整時期的成交量總和超過套牢賣壓時，股價才有機會反轉向上。</p>
</li>
<li><p>個股週k線在底部明顯出量（成交量約為平時的1.5-2倍）</p>
</li>
<li><p>籌碼從猶豫者手中轉到固執者手中（如利空不跌）</p>
</li>
<li><p>W底的成交量特徵（量價同步）</p>
</li>
</ul>
<p>反之，當頭部區出現時，成交量會有以下幾種變化：</p>
<ul>
<li><p>月成交量暴增</p>
</li>
<li><p>最大量月k線的低點被跌破</p>
</li>
<li><p>月成交量出現量價背離</p>
</li>
<li><p>籌碼從固執者手中轉到猶豫者手中</p>
</li>
<li><p>M頭的成交量特徵（右峰成交量低於左峰）</p>
</li>
</ul>
<blockquote>
<p><strong>棄取理論</strong></p>
</blockquote>
<p>巴菲特有句名言是：<strong>別人貪婪時我恐懼，別人恐懼時我貪婪</strong>。當市場大多數人看壞行情時，就是空頭行情即將結束的時候；反之，當市場大多數人看好行情時，表示多頭行情即將走到盡頭。這是因為<strong>群眾是盲目的</strong>，當人們身處在群眾之中，最容易失去理性。</p>
<blockquote>
<p><strong>順勢理論</strong></p>
</blockquote>
<p>新手看價，老手看量，高手看勢，順勢操作通常都會是贏家。順勢理論由股市名人威爾斯‧威爾德發明，並稱之為「<strong>亞當理論</strong>」。順勢的精髓在於：研判股市走多頭的最佳方式，就是看到它已經在上漲。值得注意的是，亞當理論主張，當投資人進場後，開始出現虧損時，<strong>千萬不要「加碼攤平」</strong>，因為賠錢就代表自己看錯趨勢，應該盡快停損。</p>
<p>當大盤趨勢走多時，必須要追逐最強勢的類股，以台股來說，傳產股通常是漲勢最為強勁的類股，前三名為<strong>汽車類、玻璃陶瓷類、建材營造類</strong>。另外，追逐時下最夯的產業，也是順勢操作的手法之一。</p>
<blockquote>
<p><strong>停損理論</strong></p>
</blockquote>
<p>相較於定存，股票本身是風險較高的投資，即便是股市高手也會看錯行情。因此在<strong>進場前，就必須嚴設停損點</strong>，才能在投資失利時，將自己平安帶出場。美國股市作家吉姆‧史洛門所（Jim Sloman）認為停損有三個要點：</p>
<ul>
<li><p>在進場前，就必須先設下自己可以接受的停損點</p>
</li>
<li><p><strong>進場前的停損點絕對不能更動</strong>，這樣才能保持客觀</p>
</li>
<li><p>切勿因小失大，看錯行情就要立刻停損</p>
</li>
</ul>
<p>作者提供三種停損的方法：當股市跌破重要支撐點時、當買進的理由改變時、當股價跌破一定的百分比（如10%）時。</p>
<p>最後，低檔買進股票也要設停損點，而<strong>放空更需要設停損點</strong>，因為做多頂多虧損100%（股票跌到0元），做空的虧損理論上可以無限大（股票一直上漲）。</p>
<blockquote>
<p><strong>抱股理論</strong></p>
</blockquote>
<p>美國投機大師傑西‧李佛摩（Jesse Livermore）認為：在多頭行情裡，只需要做二件事：<strong>底部區買進</strong>與<strong>緊抱持股</strong>。台灣《理財聖經》的作者黃培源也曾提出類似的概念，他認為投資股票只有九個字：<strong>隨便買、隨時買、不要賣</strong>。主要原因是因為股市基本上是長期看漲的，所以只要身邊有錢，就可以去買股票，並且盡量不要賣出，否則高額的手續費和交易稅都會侵蝕利潤。</p>
<p>其實，要在股市抓到底部不難，難的是長抱持股。大多數人總是在股市中小賺大賠，就是因為貪圖眼前的蠅頭小利，導致在買進股票後，很快就停利，然後又在股票上漲時追高進場，最後慘遭套牢，導致大賠。</p>
<p>抱股理論要<strong>搭配位置理論</strong>使用，先用位置理論判斷出底部後，勇敢買進股票，然後緊抱持股，最後再透過位置理論判斷頭部，果斷賣出。</p>
<blockquote>
<p><strong>主力理論</strong></p>
</blockquote>
<p>股票如果沒有主力拉抬，是不會飆漲的。想在股市賺錢，一定要洞悉主力的思考模式和操作手法。一般而言，主力在操作一檔股票時，有以下幾個步驟：</p>
<ul>
<li><p>挑選標的</p>
<p>主力挑選的標的通常會具備幾種要件：<strong>股本小（10億以下，容易拉抬）、股性投機、具備炒作題材（如景氣循環）</strong>等。</p>
</li>
<li><p>估算籌碼</p>
<p>主力在估算籌碼時，會考慮幾個要素：計算市場浮額（依照上市櫃公司的資本額以及每股10元，算出市場上發行的所有股數，再扣掉董監等大股東的持股，剩下的股票就是<strong>市場浮額</strong>）、估計需要吸納的籌碼（通常是<strong>市場浮額的三成</strong>）。</p>
</li>
<li><p>搭配外圍炒作</p>
<p>如基金經理人、外資、自營商、其他主力、投顧老師、媒體等。</p>
</li>
<li><p>進貨</p>
<p>時程一般落在<strong>三個月到六個月</strong>之間。</p>
</li>
<li><p>拉抬</p>
<p>主力都是熟悉<strong>技術分析的高手</strong>，他們會精算市場浮額，並依照波浪理論或技術分析將股價拉抬到相對應的位置。</p>
</li>
<li><p>洗盤</p>
<p>主力在拉抬股價的過程中，通常會伴隨著洗盤或回檔整理。主要是為了洗出底部區進場的投資人，以及吸引新的投資人進場。常見的洗盤方式有三種：<strong>高出低進法、定點洗盤法、跌停洗盤法</strong>。其中，跌停洗盤是最激進的洗盤法，在沒有大利空的情況下，突然讓股價跌停，誘使投資人交出手中的籌碼，筆者在去年就曾經遇到過（淚）。幸好當時並沒有被甩掉，並且在接下來三個多月的盤整也沒有交出手中籌碼，最後才迎來今年的波段獲利。</p>
  <img src="/2021/09/12/stock-position/2376-week-202109.JPG" class=""></li>
<li><p>出貨 </p>
<p>正所謂「萬般拉抬皆為出」，主力出貨的手法有：<strong>拉高出貨法、壓低出貨法、震盪出貨法</strong>。</p>
</li>
</ul>
<p>除了操作股票的步驟外，主力還有一些操作股票的心態和習性：</p>
<ul>
<li><p>若非當時的當紅產業、公司沒有大利多，主力通常不敢介入</p>
</li>
<li><p><strong>主力炒作股票不會二、三個漲停板就結束</strong>，其漲幅通常以倍數來計算</p>
<p>筆者以今年大爆發的友達為例，2020/12/04出現過前高的漲停板，即暗示著未來的波段行情。不過，在隨後的二個月，友達呈現盤整期間，並且成交量相較過去幾周有逐漸放大的趨勢，顯示市場熱度正在增加，且主力洗盤中，這也印證了本書所述的主力操作手法。</p>
<img src="/2021/09/12/stock-position/2409-week-202109.JPG" class=""></li>
<li><p><strong>只有主力介入的股票才會飆漲</strong>，而且通常會以長紅k或跳空的方式越過前高或頸線等大型壓力區</p>
</li>
<li><p>在炒作的過程中，主力最在乎的是<strong>收盤價</strong>，因此可以從股票的收盤價看出是否有主力介入</p>
</li>
<li><p><strong>主力並不是每一次的炒作都會成功</strong>，偶爾也會遇到對作或是突發的利空而失敗出場，此時k線就會出現跌破大支撐的現象</p>
</li>
</ul>
<blockquote>
<p><strong>選股理論</strong></p>
</blockquote>
<p>股市中存在著二種股票，一種為績優股，另一種為投機股。績優股通常具備幾種特性，例如：在該產業中是數一數二的龍頭股、上市多年來獲利率超過10%、業績持續成長、具公信力等。購買績優股的投資人，應該對績優股有正確的認識。首先，績優股沒有飆漲的條件，這是因為績優股的股本通常很大，不容易拉抬，且投資績優股的人多半是穩健型的投資人，不太會去哄抬或炒作股價。其次，購買績優股是著眼於<strong>配股配息</strong>，必須長期投資始見<strong>複利的效益</strong>。</p>
<p>相反的，想購買投機股應該有以下幾點認識，第一，投機股是著眼於<strong>階段性價差</strong>，進出場要眼明手快，當股價漲到目標價後，就馬上獲利了結；當股價跌過停損點後，馬上損出。其次，玩投機股必須具備一定的功力，除了要對技術面瞭若指掌外，也要對籌碼、主力有相當程度的理解，才能在股市獲取報酬。</p>
<p>&nbsp;</p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>本書的核心思想是「<strong>低買高賣</strong>」，也就是書中所述的位置理論。為了達到這個目的，需要有其他對應的資訊來幫助判斷股票什麼位置是「低」，什麼位置是「高」，以及什麼時候要「買」，什麼時候要「賣」，故而衍伸出其他理論。</p>
<p>例如價值理論可以幫助投資人判斷某檔股票的股價是否合理，循環理論則幫助投資人判斷股價未來的趨勢，而時間理論幫助投資人判斷趨勢持續的時間。籌碼與主力理論幫助投資人判斷市場大戶的動向，再搭配順勢、棄取理論進場操作。而在投資股票的過程中，如果操作不慎，則可以透過停損理論降低虧損；反之，如果看對方向的話，則根據抱股理論長抱持股。當然，投資人必須清楚知道自己持有的股票是績優股還是投機股，以便選擇相對應的操作。</p>
<p>整體而言，這本書對股市作了一個相當不錯的全面性總結，屬於<strong>大面相觀念書</strong>。書中所述的理論都是符合邏輯、非常實用的觀念，而不是牽強地去解釋歷史股價，建議重複閱讀，並將這些觀念內化到自己的思想中。本書所涵蓋的範圍包含股市的各個面向，例如<strong>基本面、技術面、籌碼面、消息面</strong>等，但並沒有針對各個面向仔細地介紹，而是將這些面向統整成一個單一的理論，然後用理論去解釋股市在多頭或空頭時，各個面向會如何反應。此外，本書的用字遣詞大多屬於股市的術語，例如k線、籌碼、底部、頭部等，因此適合已經在股市打滾一陣子、股齡約一到二年的投資人，<strong>較不適合新手閱讀</strong>。</p>
<p>對我來說，讀這本書最大的收穫是：<strong>機會是「等」來的</strong>。想要在股市中賺錢，不外乎低買高賣，或者低買後長抱。但是，低價的股票並不是每天都有，而是需要長時間的等待，這個觀念抑制了我追漲的衝動，降低被套牢的風險。另一方面，<strong>主力理論</strong>是我先前比較少接觸到的領域，讀完後猶如醍醐灌頂，讓我明白為什麼股票會有拉抬、回檔、洗盤、出貨等階段。回頭對照以前操作過的股票後，真是令我會心一笑，原來主力在股市根本毫不掩藏（笑）。最後，作者有提到，這些理論是他在讀完數十本股市經典的書籍後所整理出來的，我認為這份<strong>書單</strong>對於投資人有相當大的參考價值，如果讀完本書覺得意猶未盡的話，可以再深入去看這些經典書籍。</p>
<p>總的來說，這是一本值得閱讀的財經書籍，熟記這些理論，並做好風險控管，相信大家都能在股海中獲利！</p>
<p>&nbsp;</p>
<h3 id="書目資訊"><a href="#書目資訊" class="headerlink" title="書目資訊"></a>書目資訊</h3><p>書名：看準位置，只賺不賠：掌握投資11大關鍵理論，買股不受傷<br>作者：郭泰<br>出版社：遠流<br>出版日期：2018/05/30</p>
<p>&nbsp;</p>
<h3 id="作者介紹"><a href="#作者介紹" class="headerlink" title="作者介紹"></a>作者介紹</h3><p><strong>郭泰</strong>，政大新聞系畢業。曾任中國時報記者、世新大學講師、哈佛企管顧問公司副總經理等職。研究股票數十年，悟出市場真諦後，提出「位置理論」，成為技術派重要的理論之一。</p>
<p>郭泰的著作頗多，範圍也十分廣泛，包含企業人物、理財投資、個人競爭、勵志等。筆法深入淺出，曾榮獲「金鼎獎」與「金書獎」。</p>
]]></content>
      <categories>
        <category>書摘</category>
      </categories>
      <tags>
        <tag>股票</tag>
        <tag>投資</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 983. Minimum Cost For Tickets</title>
    <url>/2021/09/02/min-cost-ticket/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.</p>
<p>Train tickets are sold in three different ways:</p>
<ul>
<li>a 1-day pass is sold for costs[0] dollars,</li>
<li>a 7-day pass is sold for costs[1] dollars, and</li>
<li>a 30-day pass is sold for costs[2] dollars.</li>
</ul>
<p>The passes allow that many days of consecutive travel.</p>
<ul>
<li>For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.</li>
</ul>
<p>Return the minimum number of dollars you need to travel every day in the given list of days.</p>
<p>這是我第一次碰到 dynamic programming (DP) 問題，其實最早碰到的應該是費布納西數列，不過那個問題相對簡單。</p>
<span id="more"></span>

<p>本題考 DP 觀念，想法上是第 i 天的花費，是截至第 i-1 天的花費再加上當天的花費。因此，如果第 i 天不用旅遊的話，那該天的花費就是累積到第 i-1 天的花費。反之，如果第 i 天要旅遊的話，那麼有三種情況，分別是第 i-1 天加上 1-day pass、第 i-7 天加上 7-day pass、第 i-30 天加上 30-day pass。透過這種推法，就能導出每個 travel day 的最低花費。要注意的是，起始值 DP(0) 要給一個合理的數字，才能透過 DP 演算法一直往下推 DP(1), DP(2), …, DP(t)。本題把 DP(0) 設為 0 （花費為 0）是個合理的設定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span>(<span class="params">self, days: <span class="type">List</span>[<span class="built_in">int</span>], costs: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * <span class="number">366</span></span><br><span class="line">        <span class="keyword">for</span> day <span class="keyword">in</span> days:</span><br><span class="line">            dp[day] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># set initial point</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">366</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i] == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>):</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                case1 = dp[<span class="built_in">max</span>(i-<span class="number">1</span>, <span class="number">0</span>)] + costs[<span class="number">0</span>]</span><br><span class="line">                case2 = dp[<span class="built_in">max</span>(i-<span class="number">7</span>, <span class="number">0</span>)] + costs[<span class="number">1</span>]</span><br><span class="line">                case3 = dp[<span class="built_in">max</span>(i-<span class="number">30</span>, <span class="number">0</span>)] + costs[<span class="number">2</span>]</span><br><span class="line">                </span><br><span class="line">                dp[i] = <span class="built_in">min</span>(case1, case2, case3)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[days[-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程式</category>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 15. 3Sum</title>
    <url>/2021/09/01/three-sum/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j, i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<p>題目是給定一串數列，找出所有3個為一組且不重複的 triplets，使得這3個數字的總合為0。</p>
<p>這題的解法比較複雜，首先，最簡單的做法是暴力解，需要考慮 <code>nums</code> 中所有可能的 triplets，時間複雜度會是 $O(N^3)$。</p>
<span id="more"></span>

<p>第二種解法需要用到二個指針的操作，並且假設 <code>nums</code> 是已經排序過的。針對一個已經排序的 <code>nums</code>，例如題目給的例子是 <code>[-1,0,1,2,-1,-4]</code>，排序後為 <code>[-4,-1,-1,0,1,2]</code>，目標是要在這裡面找到 a, b, c 三個數字，使得 a + b + c = 0。因為 <code>nums</code> 已經排序過，我們可以假設 a &lt; b &lt; c，先把 a 當成第一個數字，也就是 -4，接下來要找的 b 和 c 必須符合 b + c = -4。找法是先放二個指針，一個在頭，一個在尾，例如 b = -1, c = 2，然後把它們相加，如果和比 a 小，表示 b 要往右邊移動去找更大的數字（因為 <code>nums</code> 已經排序）；反之，如果和比 a 大，那麼 c 就要往左移動，去找更小的數字。</p>
<p>另一種解法和前述雙指針的解法類似，一樣先將 <code>nums</code> 排序，接著從第一個數開始，依序當作 triplets 中的一個數值 v，然後從剩下的數去找 triplets 中的另外二個數字。假設另外二個數值其中一個是 x，則另一個一定是 -v-x，三者相加 v + x + (-v-x) = 0。重複前面的步驟，遍歷 <code>nums</code> 中所有的數字，就能得到所有的 triplets。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums[:n-<span class="number">2</span>]):</span><br><span class="line">            <span class="comment"># if nums[i] = nums[i-1], no need to check</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums[(i+<span class="number">1</span>):]:</span><br><span class="line">                <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[-v-x] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.add((v, -v-x, x))</span><br><span class="line">        <span class="keyword">return</span> res        </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程式</category>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 5. Longest Palindromic Substring</title>
    <url>/2021/09/01/longest-palindromic-subs/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a string s, return the longest palindromic substring in s.</p>
<p>本題主要考 string 操作。想法上先建一個 helper function 來找回文的 substring，然後從 string 頭開始，依序帶入 substring 去找回文，並在過程中儲存目前長度最長的 substring，最後便可找到答案。</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            subs = self.find_palindrome(s[i:])</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(subs) &gt; max_len:</span><br><span class="line">                max_len = <span class="built_in">len</span>(subs)</span><br><span class="line">                ans = subs</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_palindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>):</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        end = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            end = s.find(s[<span class="number">0</span>], end+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> end == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            subs = s[:(end+<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">if</span> subs == subs[::-<span class="number">1</span>]:</span><br><span class="line">                res = subs</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程式</category>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3. Longest Substring Without Repeating Characters</title>
    <url>/2021/08/31/longest-substring-no-repeat/</url>
    <content><![CDATA[<p>Given a string s, find the length of the longest substring without repeating characters.</p>
<p>本題主要測驗 string 的操作，如 slicing 及找尋 substring。解法是依序建立 substring，當遇到有重複的字元時，拿掉該字元以前的所有字元，從該重複字元的下一個開始，並且新增當前的字元。依此類推，當遇到比較長的 substring 時，更新 substring 的長度。全部跑完就能得到最長的 substring。</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        subs = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> subs:</span><br><span class="line">                <span class="keyword">if</span> ans &lt; <span class="built_in">len</span>(subs):</span><br><span class="line">                    ans = <span class="built_in">len</span>(subs)</span><br><span class="line">                </span><br><span class="line">                pos = subs.find(x) + <span class="number">1</span></span><br><span class="line">                subs = subs[pos:] + x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                subs += x</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ans &lt; <span class="built_in">len</span>(subs):</span><br><span class="line">            ans = <span class="built_in">len</span>(subs)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程式</category>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2. Add Two Numbers</title>
    <url>/2021/08/29/add-two-numbers/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>這題主要測驗的是 <code>Linked list</code> 的操作，以及餘數的處理。首先新增一個空的 <code>List</code>，並新建一個餘數。接著，遍歷 <code>l1</code> 及 <code>l2</code>，當有述職的時候，就按照位置相加，並且更新餘數，直到 <code>l1</code> 及 <code>l2</code> 都沒有 <code>next</code>。</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        head = ans = ListNode()</span><br><span class="line">        remainder = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> remainder:</span><br><span class="line">            l1_val = l1.val <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            l2_val = l2.val <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            summation = l1_val + l2_val + remainder</span><br><span class="line">            remainder = summation // <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            ans.<span class="built_in">next</span> = ListNode(summation % <span class="number">10</span>)</span><br><span class="line">            ans = ans.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程式</category>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1. Two Sum</title>
    <url>/2021/08/29/two-sum/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>You can return the answer in any order.</p>
<p>一開始的思路是暴力解法，遍歷 <code>nums</code> 中每個數字，然後找該數字是否和後面的數字相加得到 <code>target</code>，不過這個方法最差的情況應該會是 <code>n!</code>，所以換個方式。</p>
<span id="more"></span>

<p>另一個想法是從減法的角度來解，並解透過 hash table 來記錄 <code>nums</code> 中所有元素的 index。做法如下：先建立一個 hash_table，然後遍歷 <code>nums</code> 中所有元素，計算當下元素和 <code>target</code> 的差，然後看 hash_table 裡面有沒有這個差，有的話，等於是得到答案：因為當前這個數字與 hash_table 裡的元素的和就是 <code>target</code>，因此，只要返回當前元素的 index 以及 hash_table 中差值元素的 index 即可。</p>
<p>如果差不存在的話，則將目前的元素及其 index 存入 hash_table，繼續找下一個。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hash_table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            diff = target - num</span><br><span class="line">            <span class="keyword">if</span> diff <span class="keyword">in</span> hash_table.keys():</span><br><span class="line">                <span class="keyword">return</span> [hash_table[diff], i]</span><br><span class="line">            hash_table[num] = i</span><br><span class="line">            </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程式</category>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 27. Remove element</title>
    <url>/2021/08/29/remove-element/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.</p>
<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.</p>
<p>Return k after placing the final result in the first k slots of nums.</p>
<p>Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>題目並不難，大意是給定一個含有整數的陣列 <code>nums</code> 及一個整數 <code>val</code>，要把 <code>nums</code> 中所有的 <code>val</code> 都刪掉，然後返回剩餘陣列的長度。條件是必須在 O(1) 的記憶體實現。</p>
<p>在 python 中，可以透過 <code>list.remove(val)</code> 刪除 <code>list</code> 中的 <code>val</code>。由於 <code>list.remove()</code> 只能刪除第一個出現的 <code>val</code>，因此，透過 while 迴圈來刪除所有 <code>val</code>，同時透過 has_element 這個 tag 來判斷 <code>nums</code> 中是否還有 <code>val</code>，如果已經全部刪除的話，則結束迴圈。</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        has_element = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> has_element:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                nums.remove(val)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                has_element = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程式</category>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>結果，立刻去做的人得到一切</title>
    <url>/2021/07/18/do-right-now/</url>
    <content><![CDATA[<img src="/2021/07/18/do-right-now/do-right-now-cover.jpeg" class="">


<p>&nbsp;</p>
<p><em><strong>工作、財富、夢想……</strong></em></p>
<p><em><strong>只要 10 秒鐘 ，一切不再遙不可及！</strong></em></p>
<p><em><strong>只要 10 秒鐘，你就能擺脫拖延的人生，成為立刻付諸行動的人。</strong></em></p>
<p>&nbsp;</p>
<p>你是不是常常訂好了目標，但卻一直無法展開行動？</p>
<p>你是不是常常覺得時間還很多，不如先耍廢一下？</p>
<p>你是不是總是要拖到最後一刻，才開始焦慮地工作？</p>
<p>本書提供你一些小撇步，教你如何提升自己的行動力，擺脫拖延的習慣！</p>
<p>讀完本篇，你將會知道：</p>
<ul>
<li><p>決定你要不要立刻去做一件事情的，不是動力，而是「心情」</p>
</li>
<li><p>心情是可以控制的，只要把心情控制在對的狀態下，就能有行動力</p>
</li>
<li><p>透過轉換視角，可以幫助自己理出行動的頭緒，降低行動門檻</p>
</li>
<li><p>提升周遭的人的效率，讓自己的效率再上一層樓</p>
</li>
</ul>
<span id="more"></span>


<p>&nbsp;</p>
<h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>這是一本很不錯的<strong>工具書</strong>，提供很多讓人「立刻行動」的實用技巧。此外，本書還點出一般人對於行動力的誤解，說明人的行動力不是來自於想完成某件事情的「動機」，而是來自於「<strong>心情</strong>」。</p>
<blockquote>
<p><strong>拖延的原因</strong></p>
</blockquote>
<p>一開始，作者先說明為什麼我們很難立刻去做某件事情，這是因為我們有一些<strong>阻礙行動思考的習慣</strong>，也就是說，雖然我們知道自己想做什麼，知道什麼事情非做不可，但一旦要執行時，就會對自己的行動踩煞車。</p>
<p>很多人可能都沒注意到自己的這個習慣，因此，想要成為立刻採取行動的人，就要先<strong>認識自己的思考習慣</strong>。這些阻礙行動思考的習慣，不外乎是由以下幾點因素所形成：</p>
<p>&diams; 對時間的掌控能力不好</p>
<p>我們在剛開始執行計畫的時候，常常會因為距離期限還有N小時、N天、N個月，就覺得時間還很充裕，不用馬上做。但是，這種「<strong>覺得時間還很多</strong>」的錯覺，是因為自己對於整個計畫沒有全盤的了解，導致錯估了計畫時間軸的結果。而等到最後真的快來不及的時候，還會因為要做的事情太多，而發生<strong>腦袋凍結</strong>，陷入無法思考的窘境。</p>
<p>例如，學期初的時候總覺得時間還很多，不用急著念書，等到快要期中考的時候，才發現有一大堆科目沒念，一時之間也不知道要從哪開始念起。這種情形就是在一開始錯估了期中考的難易度，以及自己念書所需的時間，才會出現一再拖延的情形，導致最後不得不臨時抱佛腳。</p>
<p>&diams; 身處在錯誤的情緒下</p>
<p>決定我們要不要去做某件事情的因素，其實不是想完成某件事情的動機，而是當下的<strong>心情</strong>。例如，我們有時明明想著「要減肥」、「要認真」、「要做一些有意義的事情」，心裡雖然有想做這些事情的動機，但卻常常為了一點小事就失去幹勁，或是突然覺得做起來好麻煩。這並不是因為我們不想做那些事情，而是因為當下的心情不適合做這些事情。回想一下自己專注在做某件事情的時候，心情是不是常常是有幹勁的呢？</p>
<blockquote>
<p><strong>心情</strong></p>
</blockquote>
<p>既然心情才是驅動我們去做某件事情的原動力，那麼盡量讓自己保持在一個有幹勁的情緒下，就能讓自己擁有很強的行動力。但是，要怎麼讓自己保持在有幹勁的情緒呢？首先，我們必須先認識到：</p>
<p><code>心情是可以控制的</code></p>
<p>現在，試著回想一件讓你覺得很氣憤的事情，可以是很久以前的事情，也可以是最近發生的事情。例如：某人欠你錢不還、路上突然有三寶衝出來、雙11沒搶到優惠、政客睜眼說瞎話等等。</p>
<p>是不是覺得有點生氣？</p>
<p>原本你在閱讀讀本篇文章的時候，應該是沒有什麼事情讓你感到生氣，但經由回想，你還是感受到憤怒。事實上，不只是憤怒的情緒，大部分的情緒都可以透過一些手法來生成或抑制。作者在書中提供了幾個<strong>重整心情</strong>的方法：</p>
<ul>
<li><p>利用<strong>表情、動作、話語</strong>來切換心情</p>
</li>
<li><p>透過<strong>回憶</strong>改變心情</p>
</li>
<li><p>靠<strong>想像</strong>改變心情</p>
</li>
</ul>
<p>例如，我們可以透過大笑、誇張地放生大笑，讓自己憑空得到快樂；我們也能透過回想一些有趣的事情，讓心情感到愉悅；就算沒有回憶，我們也能透過想像一些有趣的事情或畫面，讓自己感到快樂。</p>
<p><strong>環境</strong>也是影響心情的重要因素，例如在自己的工作、學習環境擺設一些自己喜歡的裝飾品，把周遭打造得像自己的家，就能讓自己維持好心情。</p>
<p>總而言之，找到適合自己的方法來調適心情，把情緒維持在一個適合做事的狀態，就能大大提升自己的行動力。</p>
<blockquote>
<p><strong>轉換視角</strong></p>
</blockquote>
<p>除了將自己的心情控制在具有高行動力的狀態，另一個提升行動力的重點是<strong>視角轉換</strong>。所謂的視角轉換，就是：</p>
<p><code>對於同一件事情，利用不同的觀點、立場、條件去思考。</code></p>
<p>透過視角轉換，就能避免在單一視角下可能會遇到的盲點。當你能夠從不同的面相來思考同一件事情的時候，就能對該件事情有越全面的了解，也就越知道該怎麼去執行，降低錯估的機率。</p>
<p>例如上述「覺得時間還很多」的例子，有很大一部份原因是只用單一視角去評估。如果在期初的時候，就能夠站在「期中的自己」去思考，或是從不同的角度去看待目前的時間規劃，就比較容易判斷下一步該怎麼走。一旦有了頭緒，就能大幅地降低行動的門檻，提高行動力。</p>
<p>書中還有討論其他阻礙行動思考的習慣，這邊就不多做介紹，只舉其中一個例子－－<strong>過分想要迴避風險</strong>。</p>
<p>做任何事情都有可能失敗，而害怕失敗的想法會讓人想要逃避，導致我們不去做該做的事情。廣義地說，這裡的風險還包括一些不想面對的事物，例如某個不好的經驗或回憶，或者在做某件事情時，所感受到的痛苦感。因為不想面對這些經驗，所以產生抗拒，並選擇逃避，最後導致拖延的現象。</p>
<blockquote>
<p><strong>改變周遭</strong></p>
</blockquote>
<p>除了提升自己的行動力，我們還必須影響他人。本書提到，生活中很多事情往往不是我們自己就可以完成，需要藉助他人的幫忙，如果能讓別人也具備很強的行動力，就能進一步提升自己的效率。</p>
<p>那要如何提升他人的行動力呢？最簡單的方法不外乎是<strong>讚美</strong>他人，讓別人有自信，就能提高他們的行動力。不過，本書認為更有效的做法不是讚美，而是<strong>傳達個人訊息</strong>。所謂傳達個人訊息是指：</p>
<p><code>將自己所觀察到或感覺到，對方表現好的、了不起的、或令你欣賞的地方，把它告訴對方。</code></p>
<p>透過傳達這種屬於個人觀察所得出來的讚美，會比單純說「你很棒」還要來得具體且有效，也更能激發對方的潛能，提升對方的行動力。</p>
<blockquote>
<p><strong>設定目標</strong></p>
</blockquote>
<p>最後，空有行動力還不夠，最重要的是<strong>擁有自己的目標</strong>，才能改變人生。試著問自己：</p>
<p><code>如果沒有任何限制的話，你希望自己在哪裡做著什麼事情？</code></p>
<p>每天持續問自己這個問題，你就會越來越清楚自己的人生目標和意義，也會越來越明白那些讓你感到興奮雀躍的願景，以及永不妥協的人生價值觀。</p>
<p>&nbsp;</p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>這本書的作者文筆流暢，翻譯也翻得很順，在章節的安排上非常有架構，循序漸進，引導讀者了解拖延的原因，並分析行動力的本質，然後提出解決拖延的辦法，提升行動力。最後還順勢點出一些人生哲理以及人際關係的課題，不過只佔一小部分。</p>
<p>雖然章節的安排十分嚴謹，但每個章節內部的架構編排相對零散，在內容的陳述上，多半是由一些例子所組成。例如第一章在講為什麼人會有拖延的現象時，並不是用一個系統性的架構去解釋成因，而是舉很多可能會導致拖延習慣的例子。這些例子彼此之間不一定有前後的順序關係，也不一定有因果關係，讀起來會覺得缺乏系統性。此外，書中所舉的例子並非完全和讀者的經驗相吻合，所以有些地方讀起來可能會覺得沒有說服力。</p>
<p>不過整體而言，這些「沒感覺的例子」並不會造成太嚴重的理解障礙，也不會影響書中整體想要傳達的觀念，以及邏輯的堆疊與推演。</p>
<p>對於有拖延習慣的人來說，這本書可以提供你一些有效的方法來提升自己的行動力。不過，要擺脫拖延的習慣，最重要的事情是能夠<strong>察覺自己</strong>正在拖延的行為，分析自己拖延的原因，然後再從書中找出對應的解決辦法，實際去執行，才能真正解決拖延的問題。</p>
<p>&nbsp;</p>
<h3 id="書目資訊"><a href="#書目資訊" class="headerlink" title="書目資訊"></a>書目資訊</h3><p>書名：結果，立刻去做的人得到一切<br>作者：藤由達藏<br>譯者：李璦祺<br>出版社：方智<br>出版日期：2016/12/01</p>
<p>&nbsp;</p>
<h3 id="作者介紹"><a href="#作者介紹" class="headerlink" title="作者介紹"></a>作者介紹</h3><p><strong>藤由達藏</strong>，Seminar room gonmatus 負責人，夢想實現心理教練，以一套重視「心情與視角之轉換」的獨創方法論，提供各行各業面對面的教練學（Coaching）指導、提高原動力的培訓課程，以及創造力和能力開發的工作坊。</p>
]]></content>
      <categories>
        <category>書摘</category>
      </categories>
      <tags>
        <tag>心理學</tag>
        <tag>方法論</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT最打動人心的溝通課</title>
    <url>/2021/07/04/mit-comm/</url>
    <content><![CDATA[<img src="/2021/07/04/mit-comm/mit-comm-cover.jpg" class="">


<p>&nbsp;</p>
<h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>本書主要在探討什麼是有效的溝通，以及如何達到有效的溝通，而方法就是「<strong>謙遜提問</strong>」。</p>
<blockquote>
<p><strong>有效溝通的關鍵</strong></p>
</blockquote>
<p>良好的溝通始於<strong>互信</strong>，而互信始於謙遜提問。從心理學的角度來看，人們只有在開放、互相信賴的氛圍下，才會吐露真言。因此，要達到有效的溝通，必須先營造互相信賴的氛圍。為了達到這個目的，我們必須與他人建立關係，而建立關係最好的方式是開口「提問」，更精確來說，是「謙遜提問」。</p>
<span id="more"></span>

<blockquote>
<p><strong>引導別人打開心房</strong></p>
</blockquote>
<p>我們身處在鼓勵「<strong>說</strong>」的主流文化中，因而不善於「<strong>提問</strong>」。但是，「說」並不容易建立關係，因為「說」本身有上對下的意涵，「說」意味著有件事你應該知道，但你不知道，所以我說給你知道。相反的，「問」是將自己的姿態擺低，它所傳達的訊息是我承認自己的無知，並且我願意投入心力向你請教，這種放低姿態的行為，較容易使他人卸下心防，進而建立互信的關係。</p>
<p>信任關係之所以能夠建立，是因為我先打開了自己的心房，而對方並沒有趁此機會欺負我，於是我開始對對方產生了某種程度的信任，相對的，對方也會開始慢慢信任我，因為提問代表我關注對方，而且我很仔細聆聽對方提供的答案。</p>
<blockquote>
<p><strong>謙遜提問</strong></p>
</blockquote>
<p>問有分好幾種，如果只是單純的提問，或是表面上看起來是問，但實際上是在說的話，都無法做到有效的溝通，只有謙遜提問才能真正達到有效的溝通。所謂的謙遜提問，是指<strong>承認自己的無知，不帶任何偏見的虛心求教</strong>，它源自於我們對別人的關注與好奇心，是一種想要建立關係的渴望。</p>
<p>謙遜提問所指的「謙遜」有分三種情況，一種是<strong>基本的謙遜</strong>，這是基於傳統社會文化所產生的一種必然的、天生的謙遜，例如血統、種族等。例如在某些文化中，當人們遇到比自己優越的血統時，會表現出禮貌的行為。另一種謙遜是<strong>選擇性的謙遜</strong>，這種謙遜指的是人們對於成就高過自己的人，所表現出來的敬畏、欽佩或羨慕的行為，例如我們會對諾貝爾獎得主或奧運金牌得主展現敬意。第三種謙遜是<strong>當下的謙遜</strong>，指的是當我依賴你時的內心感受。這種謙遜展現出此刻我的狀態在你之下，因為你掌握了我想完成目標所需、但欠缺的知識或技能。當下的謙遜是謙遜提問中最重要的謙遜形式，大多數時候，我們都是基於當下的謙遜來進行謙遜提問。</p>
<blockquote>
<p><strong>因地制宜的謙遜提問</strong></p>
</blockquote>
<p>在不同的時機、場合和狀況下，會有不同形式的謙遜提問，大致上可分成診斷式提問、對質式提問、過程導向式提問。<strong>診斷式提問</strong>是一種引導對話走向的提問方式，透過提問，將話題牽引到提問者感興趣的事情上，例如詢問對方的感受與反應、起因與動機、行動導向、系統性問題等。它本質上並不是單方向的「說」，而是透過診斷提問來完成任務。<strong>對質式提問</strong>會加入自己的想法，但仍維持問題的形式。它可以再細分為詢問對方的感受、動機、行動導向等，雖然很容易流於對別人指指點點，但只要動機是出於幫忙對方，仍然可以用來建立信任關係。<strong>過程導向式提問</strong>會先暫停討論的內容，把焦點聚集在當下的互動上，例如詢問對方：「我剛才是不是問太多了？」，這種提問方式可以將彼此拉回對話本身，是破解尷尬的利器，但較難拿捏尺度。</p>
<p>無論是何種謙遜提問，在建立互信關係的過程中，都會遇到難題。只要保持誠心幫助對方的心態，就能一一化解。相反的，如果內心始終帶著高人一等的好勝心態，假裝出謙遜的樣子，終究無法使人信服。作者建議，如果總是忍不住想「說」，那就記住：<strong>聽者無心，那建議就白給了。</strong></p>
<blockquote>
<p><strong>地位、階級、角色所造成的心理障礙</strong></p>
</blockquote>
<p>不論是哪個文化，人們從小就被教導在不同的場合中，應該要如何感受及表現，這種因社會文化所形成的地位、階級或角色上的差異，會對人們造成心理障礙，阻礙謙遜提問。例如上司講話的時候，下屬就應該要專心聽，不得提出問題。為了避免這些社會規範所造成的影響，作者建議可以用<strong>個人化</strong>的方式與他人建立關係，也就是把他人視為完整的個人，而非只是執行任務的過程中所扮演的角色，這樣就能透過謙遜提問，與他人建立比任務導向更深厚的關係。</p>
<blockquote>
<p><strong>內在自我</strong></p>
</blockquote>
<p>除了社會規範，內在的四個自我也會影響溝通，造成溝通的複雜性。內在的四個自我源自於社會心理學中，幫助我們自我認識、接納與成長的周哈里窗（Johari window），根據理論，我們可以透過「自己掌握的訊息」和「別人能掌握的訊息」，將自己分割成四個範疇，包括<strong>隱藏自我、開放自我、未知自我、盲目自我</strong>。這些自我會影響日常的溝通，例如開放自我是自己和他人都知道的自我，這種自我代表的是我們願意且知道可以跟陌生人暢談的話題；而隱藏自我是自己知道但願意透露的事情。在建立關係的過程中，我們會遊走在不同的自我中，並思考要隱藏或揭露自己到什麼程度。</p>
<blockquote>
<p><strong>注意心智偏誤與知覺扭曲</strong></p>
</blockquote>
<p>人類的大腦會產生<strong>心智偏誤</strong>和<strong>知覺扭曲</strong>，若我們在對話的過程中，因為某些偏誤而誤判情勢，或者不知道什麼行為比較得體時，就無法表現出恰當的謙遜。因此，如果想讓謙遜提問發揮效果，就必須深究這些偏誤和扭曲。</p>
<p>人類複雜的心理過程可以濃縮成一個簡化的模型，由<strong>觀察（observation）、反應（reaction）、判斷（judgment）、干預（intervention）</strong>四個過程所組成，具體來說，人類會先透過觀察來蒐集環境資訊，再根據觀察結果產生相對應的反應，例如產生情緒。接著，人類會分析和判斷這些資訊，並依照理性與感性思維去策畫行動，然後實際執行（干預）。如果在第一步驟（觀察）中，就盡可能地蒐集正確的資訊並過濾偏誤，就能避免心智偏誤和知覺扭曲。</p>
<p>最後，作者總結，若要成為一個讓人心服口服的領導人，就要先明白領導始於關係的建立，而適時的謙遜提問可以啟動對話，而對話可以啟動關係的建立。因此，我們應該要努力充實自我，擴展自己的感知與洞察力；多自省，並向自己提問，然後嘗試用謙虛提問來掌握局面。</p>
<p>&nbsp;</p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>這本書的章節架構編排得相當好，前言就先總結了本書的內容，讓讀者快速瞭解內容大綱。在接下來的章節中，作者先帶出謙遜提問的基本觀念，但忽略細節不說，而是透過一些個案分析，先讓讀者體會謙遜提問的價值，然後才開始詳細解釋謙遜提問，並說明在不同文化及社會規範下，需要因地制宜使用謙遜提問。書末，作者引用心理學的理論來解釋人腦的運作模式，說明人的心智可能會產生偏誤，因此建議讀者應該努力提升自己的感知能力，以便擷取環境中正確的資訊，再選擇適當的社交行為來和他人打交道。</p>
<p>雖然這本書的架構編排得很好，但也有一些缺點。首先，作者的論述能力差強人意，常常用很長的篇幅來講一個簡單的概念，而且還講不清楚。例如作者在解釋謙遜提問的形態時，先把提問分成四種類型，分別是謙遜提問、診斷式提問、對質式提問、過程導向式提問，這種分類法會讓人以為謙遜提問和其他三種提問不同，但文中又多次提及這些提問算是謙遜提問的變形，讓人搞不清楚到底這些提問是不是謙遜提問的一種。</p>
<p>其次，這本書的說服力偏低，主要是因為書中所舉的案例大多不是生活中常見的情境，無法讓人感同身受。例如其中一個案例是作者在擔任系主任時，遇到系上電話費暴增的問題。這種案例比較像是特定的情境，而非一般化的情形。而且，作者在解決問題的過程中，所用到的謙遜提問形式也不太能用在一般的狀況，讀起來不太有說服力。</p>
<p>最後，這本書有非常多重複論證的地方，190頁的內容，大概只有40-50頁是新的資訊，讀起來有點浪費時間的感覺。</p>
<p>整體而言，本書所要闡述的觀念並不多，也不難理解。對於想要增進溝通技巧的人來說，這本書可以讓你獲得一些有關溝通的理論基礎，同時提供你一種有效的溝通技巧。對我而言，我印象比較深刻的地方是：「問」是比「說」更有效的溝通方式。這有點違反直覺，但看完解釋後，又覺得十分有道理。我認為可以試著將謙遜提問納入溝通的百寶箱中，選擇適當的時機使用它，應當就能獲得不錯的效果。</p>
<p>&nbsp;</p>
<h3 id="書目資訊"><a href="#書目資訊" class="headerlink" title="書目資訊"></a>書目資訊</h3><p>書名：MIT最打動人心的溝通課<br>作者：艾德．夏恩（Edgar H. Schein）<br>譯者：徐仕美、鄭煥昇<br>出版社：天下文化<br>出版日期：2014/12/26</p>
<p>&nbsp;</p>
<h3 id="作者介紹"><a href="#作者介紹" class="headerlink" title="作者介紹"></a>作者介紹</h3><p><strong>艾德．夏恩Edgar H. Schein</strong>，哈佛大學社會心理學博士，MIT史隆管理學院退休榮譽教授，被尊為管理學界的企業文化大師，也是當代組織心理學的創建者之一。</p>
<p>夏恩的組織研究備受讚譽，曾榮獲國際管理學會頒發的「Everett Cherrington Hughes Award」，以及及美國訓練管理者協會（ASTD）頒發的職場學習類別的終身成就獎。主要的著作是《組織文化與領導》（Organizational Culture and Leadership）、《組織心理》、《過程諮詢》等。</p>
]]></content>
      <categories>
        <category>書摘</category>
      </categories>
      <tags>
        <tag>心理學</tag>
        <tag>方法論</tag>
        <tag>溝通</tag>
      </tags>
  </entry>
  <entry>
    <title>有核不可？擁 / 反核的 33 個關鍵理由</title>
    <url>/2021/06/20/nuclear/</url>
    <content><![CDATA[<img src="/2021/06/20/nuclear/book_nuclear.jpg" class="">


<p>&nbsp;</p>
<p><em><strong>核能安全嗎？</strong></em></p>
<p><em><strong>台灣沒有核能會缺電嗎？</strong></em></p>
<p><em><strong>台灣需不需要核四？</strong></em></p>
<p><em><strong>讓我們放下意識形態，好好地思考核能吧！</strong></em></p>
<p>&nbsp;</p>
<p>讀完本篇，你將會知道：</p>
<ul>
<li>關於核四的主要核心議題，包括核安、核廢料、缺電、經濟發展、產業升級等議題</li>
</ul>
<span id="more"></span>


<p>&nbsp;</p>
<h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>本書的章節安排採用破題法，第一章就先點出本書將要探討的所有議題，帶大家快速了解幾個有關核能的重要議題，包括核四歷史、核安議題、核輻射外洩、核廢料存放、台灣用電量分析、綠電、碳排放、經濟成長、產業升級等。接著，在第二到第五章作深入的探討，一一檢視第一章所提出的議題，並點出台灣的產業現況，提出實際的解決方針。最後，作者說明<strong>自己反核的立場</strong>，以及反對的理由，並呼籲讀者，不管你支持或不支持核能，都務必要審慎思索核能的議題，<strong>再投下自己神聖的一票</strong>。</p>
<p>&nbsp;</p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>這本書是在 2013 年出版，算是核能議題很好的<strong>入門書</strong>，當時是為了因應核四公投而出版，雖然書有點舊，但在前年（2018 年）舉行的公投中，有一案也與核能相關，使得國內又掀起一波有關核能的論戰，所以這本書也滿適合現在來閱讀。</p>
<p>作者本身的立場是反核，所以書中的內容多有<strong>偏頗</strong>，大部分的參考資料都是用來佐證反核的論點，即使副標題是「擁/反核的 33 個關鍵理由」，卻看不太到支持核能的論述，只有少數幾個地方提及核能的優點，且後面常常接「但是」開頭的句子，用來否定這些優點，並承接反核的論點。因此，本書的內容並不如標題及推薦序中所呈現的客觀，是一份帶有許多主觀意見的報導。</p>
<p>雖然本書的內容不盡客觀，但整體而言，本書所提出的議題都是與核能切身相關的重要議題，因此，對於想要<strong>快速了解核能議題</strong>的人，本書還是值得一讀。</p>
<p>&nbsp;</p>
<h3 id="書目資訊"><a href="#書目資訊" class="headerlink" title="書目資訊"></a>書目資訊</h3><p>書名：有核不可？：擁／反核的33個關鍵理由<br>作者：彭明輝<br>出版社：天下雜誌<br>出版日期：2013/11/27</p>
<p>&nbsp;</p>
<h3 id="作者介紹"><a href="#作者介紹" class="headerlink" title="作者介紹"></a>作者介紹</h3><p><strong>彭明輝</strong>，劍橋大學控制工程博士，清華大學動力機械工學系榮譽退休教授。有經營一個部落格，文章內容主要是時事評論、影評、人生哲學等，有興趣的讀者可以 google 一下。</p>
]]></content>
      <categories>
        <category>書摘</category>
      </categories>
      <tags>
        <tag>核能發電</tag>
      </tags>
  </entry>
</search>
